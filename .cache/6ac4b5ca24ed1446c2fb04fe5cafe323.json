{"dependencies":[{"name":"core-js/library/fn/array/for-each","loc":{"line":3,"column":22}},{"name":"core-js/library/fn/array/filter","loc":{"line":4,"column":21}},{"name":"core-js/library/fn/array/map","loc":{"line":5,"column":18}},{"name":"call-signature","loc":{"line":6,"column":24}},{"name":"./decorate","loc":{"line":7,"column":23}},{"name":"core-js/library/fn/object/keys","loc":{"line":8,"column":19}}],"generated":{"js":"'use strict';\n\nvar forEach = require('core-js/library/fn/array/for-each');\nvar filter = require('core-js/library/fn/array/filter');\nvar map = require('core-js/library/fn/array/map');\nvar signature = require('call-signature');\nvar decorate = require('./decorate');\nvar keys = require('core-js/library/fn/object/keys');\n\n\nfunction Decorator (receiver, config) {\n    this.receiver = receiver;\n    this.config = config;\n    this.onError = config.onError;\n    this.onSuccess = config.onSuccess;\n    this.signatures = map(config.patterns, parse);\n    this.wrapOnlySignatures = map(config.wrapOnlyPatterns, parse);\n}\n\nDecorator.prototype.enhancement = function () {\n    var that = this;\n    var container = this.container();\n    var wrappedMethods = [];\n\n    function attach(matcherSpec, enhanced) {\n        var matcher = matcherSpec.parsed;\n        var methodName = detectMethodName(matcher.callee);\n        if (typeof that.receiver[methodName] !== 'function' || wrappedMethods.indexOf(methodName) !== -1) {\n            return;\n        }\n        var callSpec = {\n            thisObj: that.receiver,\n            func: that.receiver[methodName],\n            numArgsToCapture: numberOfArgumentsToCapture(matcherSpec),\n            matcherSpec: matcherSpec,\n            enhanced: enhanced\n        };\n        container[methodName] = callSpec.enhancedFunc = decorate(callSpec, that);\n        wrappedMethods.push(methodName);\n    }\n\n    forEach(filter(this.signatures, methodCall), function (matcher) {\n        attach(matcher, true);\n    });\n\n    forEach(filter(this.wrapOnlySignatures, methodCall), function (matcher) {\n        attach(matcher, false);\n    });\n\n    return container;\n};\n\nDecorator.prototype.container = function () {\n    var basement = {};\n    if (typeof this.receiver === 'function') {\n        var candidates = filter(this.signatures, functionCall);\n        var enhanced = true;\n        if (candidates.length === 0) {\n            enhanced = false;\n            candidates = filter(this.wrapOnlySignatures, functionCall);\n        }\n        if (candidates.length === 1) {\n            var callSpec = {\n                thisObj: null,\n                func: this.receiver,\n                numArgsToCapture: numberOfArgumentsToCapture(candidates[0]),\n                matcherSpec: candidates[0],\n                enhanced: enhanced\n            };\n            basement = callSpec.enhancedFunc = decorate(callSpec, this);\n        }\n    }\n    return basement;\n};\n\nDecorator.prototype.concreteAssert = function (callSpec, invocation, context) {\n    var func = callSpec.func;\n    var thisObj = this.config.bindReceiver ? callSpec.thisObj : invocation.thisObj;\n    var enhanced = callSpec.enhanced;\n    var args = invocation.values;\n    var message = invocation.message;\n    var matcherSpec = callSpec.matcherSpec;\n\n    if (context && typeof this.config.modifyMessageBeforeAssert === 'function') {\n        message = this.config.modifyMessageBeforeAssert({originalMessage: message, powerAssertContext: context});\n    }\n    args = args.concat(message);\n\n    var data = {\n        thisObj: invocation.thisObj,\n        assertionFunction: callSpec.enhancedFunc,\n        originalMessage: message,\n        defaultMessage: matcherSpec.defaultMessage,\n        matcherSpec: matcherSpec,\n        enhanced: enhanced,\n        args: args\n    };\n\n    if (context) {\n        data.powerAssertContext = context;\n    }\n\n    return this._callFunc(func, thisObj, args, data);\n};\n\n// see: https://github.com/twada/empower-core/pull/8#issuecomment-173480982\nDecorator.prototype._callFunc = function (func, thisObj, args, data) {\n    var ret;\n    try {\n        ret = func.apply(thisObj, args);\n    } catch (e) {\n        data.assertionThrew = true;\n        data.error = e;\n        return this.onError.call(thisObj, data);\n    }\n    data.assertionThrew = false;\n    data.returnValue = ret;\n    return this.onSuccess.call(thisObj, data);\n};\n\nfunction numberOfArgumentsToCapture (matcherSpec) {\n    var matcher = matcherSpec.parsed;\n    var len = matcher.args.length;\n    var lastArg;\n    if (0 < len) {\n        lastArg = matcher.args[len - 1];\n        if (lastArg.name === 'message' && lastArg.optional) {\n            len -= 1;\n        }\n    }\n    return len;\n}\n\n\nfunction detectMethodName (callee) {\n    if (callee.type === 'MemberExpression') {\n        return callee.member;\n    }\n    return null;\n}\n\n\nfunction functionCall (matcherSpec) {\n    return matcherSpec.parsed.callee.type === 'Identifier';\n}\n\n\nfunction methodCall (matcherSpec) {\n    return matcherSpec.parsed.callee.type === 'MemberExpression';\n}\n\nfunction parse(matcherSpec) {\n    if (typeof matcherSpec === 'string') {\n        matcherSpec = {pattern: matcherSpec};\n    }\n    var ret = {};\n    forEach(keys(matcherSpec), function (key) {\n        ret[key] = matcherSpec[key];\n    });\n    ret.parsed = signature.parse(matcherSpec.pattern);\n    return ret;\n}\n\n\nmodule.exports = Decorator;\n"},"hash":"c50731f8b6fe9789f3bdcf0817f51cf5"}