{"dependencies":[{"name":"md5-hex","loc":{"line":3,"column":23}},{"name":"./encoder","loc":{"line":5,"column":24}},{"name":"./pluginRegistry","loc":{"line":6,"column":31}},{"name":"./complexValues/arguments","loc":{"line":8,"column":31}},{"name":"./complexValues/arrayBuffer","loc":{"line":9,"column":33}},{"name":"./complexValues/boxed","loc":{"line":10,"column":27}},{"name":"./complexValues/dataView","loc":{"line":11,"column":30}},{"name":"./complexValues/date","loc":{"line":12,"column":26}},{"name":"./complexValues/error","loc":{"line":13,"column":27}},{"name":"./complexValues/function","loc":{"line":14,"column":30}},{"name":"./complexValues/global","loc":{"line":15,"column":28}},{"name":"./complexValues/map","loc":{"line":16,"column":25}},{"name":"./complexValues/object","loc":{"line":17,"column":28}},{"name":"./complexValues/promise","loc":{"line":18,"column":29}},{"name":"./complexValues/regexp","loc":{"line":19,"column":28}},{"name":"./complexValues/set","loc":{"line":20,"column":25}},{"name":"./complexValues/typedArray","loc":{"line":21,"column":32}},{"name":"./metaDescriptors/item","loc":{"line":23,"column":31}},{"name":"./metaDescriptors/mapEntry","loc":{"line":24,"column":35}},{"name":"./metaDescriptors/pointer","loc":{"line":25,"column":34}},{"name":"./metaDescriptors/property","loc":{"line":26,"column":35}},{"name":"./metaDescriptors/stats","loc":{"line":27,"column":33}},{"name":"./primitiveValues/boolean","loc":{"line":29,"column":29}},{"name":"./primitiveValues/null","loc":{"line":30,"column":26}},{"name":"./primitiveValues/number","loc":{"line":31,"column":28}},{"name":"./primitiveValues/string","loc":{"line":32,"column":28}},{"name":"./primitiveValues/symbol","loc":{"line":33,"column":28}},{"name":"./primitiveValues/undefined","loc":{"line":34,"column":31}}],"generated":{"js":"'use strict'\n\nconst md5hex = require('md5-hex')\n\nconst encoder = require('./encoder')\nconst pluginRegistry = require('./pluginRegistry')\n\nconst argumentsValue = require('./complexValues/arguments')\nconst arrayBufferValue = require('./complexValues/arrayBuffer')\nconst boxedValue = require('./complexValues/boxed')\nconst dataViewValue = require('./complexValues/dataView')\nconst dateValue = require('./complexValues/date')\nconst errorValue = require('./complexValues/error')\nconst functionValue = require('./complexValues/function')\nconst globalValue = require('./complexValues/global')\nconst mapValue = require('./complexValues/map')\nconst objectValue = require('./complexValues/object')\nconst promiseValue = require('./complexValues/promise')\nconst regexpValue = require('./complexValues/regexp')\nconst setValue = require('./complexValues/set')\nconst typedArrayValue = require('./complexValues/typedArray')\n\nconst itemDescriptor = require('./metaDescriptors/item')\nconst mapEntryDescriptor = require('./metaDescriptors/mapEntry')\nconst pointerDescriptor = require('./metaDescriptors/pointer')\nconst propertyDescriptor = require('./metaDescriptors/property')\nconst statsDescriptors = require('./metaDescriptors/stats')\n\nconst booleanValue = require('./primitiveValues/boolean')\nconst nullValue = require('./primitiveValues/null')\nconst numberValue = require('./primitiveValues/number')\nconst stringValue = require('./primitiveValues/string')\nconst symbolValue = require('./primitiveValues/symbol')\nconst undefinedValue = require('./primitiveValues/undefined')\n\n// Increment if encoding layout, descriptor IDs, or value types change. Previous\n// Concordance versions will not be able to decode buffers generated by a newer\n// version, so changing this value will require a major version bump of\n// Concordance itself. The version is encoded as an unsigned 16 bit integer.\nconst VERSION = 2\n\n// Adding or removing mappings or changing an index requires the version in\n// encoder.js to be bumped, which necessitates a major version bump of\n// Concordance itself. Indexes are hexadecimal to make reading the binary\n// output easier.\nconst mappings = [\n  [0x01, booleanValue.tag, booleanValue.deserialize],\n  [0x02, nullValue.tag, nullValue.deserialize],\n  [0x03, numberValue.tag, numberValue.deserialize],\n  [0x04, stringValue.tag, stringValue.deserialize],\n  [0x05, symbolValue.tag, symbolValue.deserialize],\n  [0x06, undefinedValue.tag, undefinedValue.deserialize],\n\n  [0x07, objectValue.tag, objectValue.deserialize],\n  [0x08, statsDescriptors.iterableTag, statsDescriptors.deserializeIterableStats],\n  [0x09, statsDescriptors.listTag, statsDescriptors.deserializeListStats],\n  [0x0A, itemDescriptor.complexTag, itemDescriptor.deserializeComplex],\n  [0x0B, itemDescriptor.primitiveTag, itemDescriptor.deserializePrimitive],\n  [0x0C, statsDescriptors.propertyTag, statsDescriptors.deserializePropertyStats],\n  [0x0D, propertyDescriptor.complexTag, propertyDescriptor.deserializeComplex],\n  [0x0E, propertyDescriptor.primitiveTag, propertyDescriptor.deserializePrimitive],\n  [0x0F, pointerDescriptor.tag, pointerDescriptor.deserialize],\n\n  [0x10, mapValue.tag, mapValue.deserialize],\n  [0x11, mapEntryDescriptor.tag, mapEntryDescriptor.deserialize],\n\n  [0x12, argumentsValue.tag, argumentsValue.deserialize],\n  [0x13, arrayBufferValue.tag, arrayBufferValue.deserialize],\n  [0x14, boxedValue.tag, boxedValue.deserialize],\n  [0x15, dataViewValue.tag, dataViewValue.deserialize],\n  [0x16, dateValue.tag, dateValue.deserialize],\n  [0x17, errorValue.tag, errorValue.deserialize],\n  [0x18, functionValue.tag, functionValue.deserialize],\n  [0x19, globalValue.tag, globalValue.deserialize],\n  [0x1A, promiseValue.tag, promiseValue.deserialize],\n  [0x1B, regexpValue.tag, regexpValue.deserialize],\n  [0x1C, setValue.tag, setValue.deserialize],\n  [0x1D, typedArrayValue.tag, typedArrayValue.deserialize],\n  [0x1E, typedArrayValue.bytesTag, typedArrayValue.deserializeBytes]\n]\nconst tag2id = new Map(mappings.map(mapping => [mapping[1], mapping[0]]))\nconst id2deserialize = new Map(mappings.map(mapping => [mapping[0], mapping[2]]))\n\nclass DescriptorSerializationError extends Error {\n  constructor (descriptor) {\n    super('Could not serialize descriptor')\n    this.name = 'DescriptorSerializationError'\n    this.descriptor = descriptor\n  }\n}\n\nclass MissingPluginError extends Error {\n  constructor (pluginName) {\n    super(`Could not deserialize buffer: missing plugin ${JSON.stringify(pluginName)}`)\n    this.name = 'MissingPluginError'\n    this.pluginName = pluginName\n  }\n}\n\nclass PointerLookupError extends Error {\n  constructor (index) {\n    super(`Could not deserialize buffer: pointer ${index} could not be resolved`)\n    this.name = 'PointerLookupError'\n    this.index = index\n  }\n}\n\nclass UnsupportedPluginError extends Error {\n  constructor (pluginName, serializerVersion) {\n    super(`Could not deserialize buffer: plugin ${JSON.stringify(pluginName)} expects a different serialization`)\n    this.name = 'UnsupportedPluginError'\n    this.pluginName = pluginName\n    this.serializerVersion = serializerVersion\n  }\n}\n\nclass UnsupportedVersion extends Error {\n  constructor (serializerVersion) {\n    super('Could not deserialize buffer: a different serialization was expected')\n    this.name = 'UnsupportedVersion'\n    this.serializerVersion = serializerVersion\n  }\n}\n\nfunction shallowSerializeDescriptor (descriptor, resolvePluginRef) {\n  if (!descriptor.serialize) return undefined\n\n  return serializeState(descriptor.serialize(), resolvePluginRef)\n}\n\nfunction serializeState (state, resolvePluginRef) {\n  if (Array.isArray(state)) return state.map(serializeState)\n\n  if (state && state.tag) {\n    let id, pluginIndex\n    if (tag2id.has(state.tag)) {\n      id = tag2id.get(state.tag)\n      pluginIndex = 0\n    } else {\n      const ref = resolvePluginRef(state.tag)\n      if (ref) {\n        id = ref.id\n        pluginIndex = ref.pluginIndex\n      }\n    }\n\n    if (id !== undefined) {\n      const serialized = [pluginIndex, id, shallowSerializeDescriptor(state, resolvePluginRef)]\n      serialized[encoder.descriptorSymbol] = true\n      return serialized\n    }\n  }\n\n  return state\n}\n\nfunction serialize (descriptor) {\n  const usedPlugins = new Map()\n  const resolvePluginRef = tag => {\n    const ref = pluginRegistry.resolveDescriptorRef(tag)\n    if (!ref) return null\n\n    if (!usedPlugins.has(ref.name)) {\n      // Start at 1, since 0 is reserved for Concordance's descriptors.\n      const index = usedPlugins.size + 1\n      usedPlugins.set(ref.name, Object.assign({index}, ref.serialization))\n    }\n\n    return {\n      id: ref.id,\n      pluginIndex: usedPlugins.get(ref.name).index\n    }\n  }\n\n  const seen = new Set()\n\n  const stack = []\n  let topIndex = -1\n\n  let rootRecord\n  do {\n    if (descriptor.isComplex === true) {\n      if (seen.has(descriptor.pointer)) {\n        descriptor = pointerDescriptor.describe(descriptor.pointer)\n      } else {\n        seen.add(descriptor.pointer)\n      }\n    }\n\n    let id\n    let pluginIndex = 0\n    if (tag2id.has(descriptor.tag)) {\n      id = tag2id.get(descriptor.tag)\n    } else {\n      const ref = resolvePluginRef(descriptor.tag)\n      if (!ref) throw new DescriptorSerializationError(descriptor)\n\n      id = ref.id\n      pluginIndex = ref.pluginIndex\n    }\n\n    const record = {\n      id,\n      pluginIndex,\n      children: [],\n      state: shallowSerializeDescriptor(descriptor, resolvePluginRef)\n    }\n    if (!rootRecord) {\n      rootRecord = record\n    } else {\n      stack[topIndex].children.push(record)\n    }\n\n    if (descriptor.createRecursor) {\n      stack.push({ recursor: descriptor.createRecursor(), children: record.children })\n      topIndex++\n    }\n\n    while (topIndex >= 0) {\n      descriptor = stack[topIndex].recursor()\n      if (descriptor === null) {\n        stack.pop()\n        topIndex--\n      } else {\n        break\n      }\n    }\n  } while (topIndex >= 0)\n\n  return encoder.encode(VERSION, rootRecord, usedPlugins)\n}\nexports.serialize = serialize\n\nfunction deserializeState (state, getDescriptorDeserializer) {\n  if (state && state[encoder.descriptorSymbol] === true) {\n    return shallowDeserializeDescriptor(state, getDescriptorDeserializer)\n  }\n\n  return Array.isArray(state)\n    ? state.map(item => deserializeState(item, getDescriptorDeserializer))\n    : state\n}\n\nfunction shallowDeserializeDescriptor (entry, getDescriptorDeserializer) {\n  const deserializeDescriptor = getDescriptorDeserializer(entry[0], entry[1])\n  return deserializeDescriptor(entry[2])\n}\n\nfunction deserializeRecord (record, getDescriptorDeserializer, buffer) {\n  const deserializeDescriptor = getDescriptorDeserializer(record.pluginIndex, record.id)\n  const state = deserializeState(record.state, getDescriptorDeserializer)\n\n  if (record.pointerAddresses.length === 0) {\n    return deserializeDescriptor(state)\n  }\n\n  const endIndex = record.pointerAddresses.length\n  let index = 0\n  const recursor = () => {\n    if (index === endIndex) return null\n\n    const recursorRecord = encoder.decodeRecord(buffer, record.pointerAddresses[index++])\n    return deserializeRecord(recursorRecord, getDescriptorDeserializer, buffer)\n  }\n\n  return deserializeDescriptor(state, recursor)\n}\n\nfunction buildPluginMap (buffer, options) {\n  const cache = options && options.deserializedPluginsCache\n  const cacheKey = md5hex(buffer)\n  if (cache && cache.has(cacheKey)) return cache.get(cacheKey)\n\n  const decodedPlugins = encoder.decodePlugins(buffer)\n  if (decodedPlugins.size === 0) {\n    const pluginMap = new Map()\n    if (cache) cache.set(cacheKey, pluginMap)\n    return pluginMap\n  }\n\n  const deserializerLookup = new Map()\n  if (Array.isArray(options && options.plugins)) {\n    for (const deserializer of pluginRegistry.getDeserializers(options.plugins)) {\n      deserializerLookup.set(deserializer.name, deserializer)\n    }\n  }\n\n  const pluginMap = new Map()\n  for (const index of decodedPlugins.keys()) {\n    const used = decodedPlugins.get(index)\n    const pluginName = used.name\n    const serializerVersion = used.serializerVersion\n\n    // TODO: Allow plugin author to encode a helpful message in its serialization\n    if (!deserializerLookup.has(pluginName)) {\n      throw new MissingPluginError(pluginName)\n    }\n    if (serializerVersion !== deserializerLookup.get(pluginName).serializerVersion) {\n      throw new UnsupportedPluginError(pluginName, serializerVersion)\n    }\n\n    pluginMap.set(index, deserializerLookup.get(pluginName).id2deserialize)\n  }\n\n  if (cache) cache.set(cacheKey, pluginMap)\n  return pluginMap\n}\n\nfunction deserialize (buffer, options) {\n  const version = encoder.extractVersion(buffer)\n  if (version !== VERSION) throw new UnsupportedVersion(version)\n\n  const decoded = encoder.decode(buffer)\n  const pluginMap = buildPluginMap(decoded.pluginBuffer, options)\n\n  const descriptorsByPointerIndex = new Map()\n  const mapPointerDescriptor = descriptor => {\n    if (descriptor.isPointer === true) {\n      if (!descriptorsByPointerIndex.has(descriptor.index)) throw new PointerLookupError(descriptor.index)\n\n      return descriptorsByPointerIndex.get(descriptor.index)\n    } else if (descriptor.isComplex === true) {\n      descriptorsByPointerIndex.set(descriptor.pointer, descriptor)\n    }\n    return descriptor\n  }\n\n  const getDescriptorDeserializer = (pluginIndex, id) => {\n    return (state, recursor) => {\n      const deserializeDescriptor = pluginIndex === 0\n        ? id2deserialize.get(id)\n        : pluginMap.get(pluginIndex).get(id)\n\n      return mapPointerDescriptor(deserializeDescriptor(state, recursor))\n    }\n  }\n  return deserializeRecord(decoded.rootRecord, getDescriptorDeserializer, buffer)\n}\nexports.deserialize = deserialize\n"},"hash":"3b32b3e6a74415193a641cda5b5fc721"}