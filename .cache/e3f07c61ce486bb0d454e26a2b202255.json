{"dependencies":[{"name":"events","loc":{"line":2,"column":29}},{"name":"fn-name","loc":{"line":3,"column":23}},{"name":"./concurrent","loc":{"line":4,"column":27}},{"name":"./sequence","loc":{"line":5,"column":25}},{"name":"./test","loc":{"line":6,"column":21}}],"generated":{"js":"'use strict';\nconst EventEmitter = require('events');\nconst fnName = require('fn-name');\nconst Concurrent = require('./concurrent');\nconst Sequence = require('./sequence');\nconst Test = require('./test');\n\nclass TestCollection extends EventEmitter {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\tthis.bail = options.bail;\n\t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n\t\tthis.compareTestSnapshot = options.compareTestSnapshot;\n\t\tthis.hasExclusive = false;\n\t\tthis.testCount = 0;\n\n\t\tthis.tests = {\n\t\t\tconcurrent: [],\n\t\t\tserial: []\n\t\t};\n\n\t\tthis.hooks = {\n\t\t\tbefore: [],\n\t\t\tbeforeEach: [],\n\t\t\tafter: [],\n\t\t\tafterAlways: [],\n\t\t\tafterEach: [],\n\t\t\tafterEachAlways: []\n\t\t};\n\n\t\tthis.pendingTestInstances = new Set();\n\n\t\tthis._emitTestResult = this._emitTestResult.bind(this);\n\t}\n\n\tadd(test) {\n\t\tconst metadata = test.metadata;\n\t\tconst type = metadata.type;\n\n\t\tif (!type) {\n\t\t\tthrow new Error('Test type must be specified');\n\t\t}\n\n\t\tif (!test.title && test.fn) {\n\t\t\ttest.title = fnName(test.fn);\n\t\t}\n\n\t\t// Workaround for Babel giving anonymous functions a name\n\t\tif (test.title === 'callee$0$0') {\n\t\t\ttest.title = null;\n\t\t}\n\n\t\tif (!test.title) {\n\t\t\tif (type === 'test') {\n\t\t\t\ttest.title = '[anonymous]';\n\t\t\t} else {\n\t\t\t\ttest.title = type;\n\t\t\t}\n\t\t}\n\n\t\tif (metadata.always && type !== 'after' && type !== 'afterEach') {\n\t\t\tthrow new Error('\"always\" can only be used with after and afterEach hooks');\n\t\t}\n\n\t\t// Add a hook\n\t\tif (type !== 'test') {\n\t\t\tif (metadata.exclusive) {\n\t\t\t\tthrow new Error(`\"only\" cannot be used with a ${type} hook`);\n\t\t\t}\n\n\t\t\tthis.hooks[type + (metadata.always ? 'Always' : '')].push(test);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.testCount++;\n\n\t\t// Add `.only()` tests if `.only()` was used previously\n\t\tif (this.hasExclusive && !metadata.exclusive) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (metadata.exclusive && !this.hasExclusive) {\n\t\t\tthis.tests.concurrent = [];\n\t\t\tthis.tests.serial = [];\n\t\t\tthis.hasExclusive = true;\n\t\t}\n\n\t\tif (metadata.serial) {\n\t\t\tthis.tests.serial.push(test);\n\t\t} else {\n\t\t\tthis.tests.concurrent.push(test);\n\t\t}\n\t}\n\n\t_skippedTest(test) {\n\t\treturn {\n\t\t\trun: () => {\n\t\t\t\tthis._emitTestResult({\n\t\t\t\t\tpassed: true,\n\t\t\t\t\tresult: test\n\t\t\t\t});\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n\n\t_emitTestResult(result) {\n\t\tthis.pendingTestInstances.delete(result.result);\n\t\tthis.emit('test', result);\n\t}\n\n\t_buildHooks(hooks, testTitle, context) {\n\t\treturn hooks.map(hook => {\n\t\t\tconst test = this._buildHook(hook, testTitle, context);\n\n\t\t\tif (hook.metadata.skipped || hook.metadata.todo) {\n\t\t\t\treturn this._skippedTest(test);\n\t\t\t}\n\n\t\t\treturn test;\n\t\t});\n\t}\n\n\t_buildHook(hook, testTitle, contextRef) {\n\t\tlet title = hook.title;\n\n\t\tif (testTitle) {\n\t\t\ttitle += ` for ${testTitle}`;\n\t\t}\n\n\t\tif (!contextRef) {\n\t\t\tcontextRef = null;\n\t\t}\n\n\t\tconst test = new Test({\n\t\t\tcontextRef,\n\t\t\tfailWithoutAssertions: false,\n\t\t\tfn: hook.fn,\n\t\t\tcompareTestSnapshot: this.compareTestSnapshot,\n\t\t\tmetadata: hook.metadata,\n\t\t\tonResult: this._emitTestResult,\n\t\t\ttitle\n\t\t});\n\t\tthis.pendingTestInstances.add(test);\n\t\treturn test;\n\t}\n\n\t_buildTest(test, contextRef) {\n\t\tif (!contextRef) {\n\t\t\tcontextRef = null;\n\t\t}\n\n\t\ttest = new Test({\n\t\t\tcontextRef,\n\t\t\tfailWithoutAssertions: this.failWithoutAssertions,\n\t\t\tfn: test.fn,\n\t\t\tcompareTestSnapshot: this.compareTestSnapshot,\n\t\t\tmetadata: test.metadata,\n\t\t\tonResult: this._emitTestResult,\n\t\t\ttitle: test.title\n\t\t});\n\t\tthis.pendingTestInstances.add(test);\n\t\treturn test;\n\t}\n\n\t_buildTestWithHooks(test) {\n\t\tif (test.metadata.skipped || test.metadata.todo) {\n\t\t\treturn new Sequence([this._skippedTest(this._buildTest(test))], true);\n\t\t}\n\n\t\tconst context = {context: {}};\n\n\t\tconst beforeHooks = this._buildHooks(this.hooks.beforeEach, test.title, context);\n\t\tconst afterHooks = this._buildHooks(this.hooks.afterEach, test.title, context);\n\n\t\tlet sequence = new Sequence([].concat(beforeHooks, this._buildTest(test, context), afterHooks), true);\n\t\tif (this.hooks.afterEachAlways.length > 0) {\n\t\t\tconst afterAlwaysHooks = new Sequence(this._buildHooks(this.hooks.afterEachAlways, test.title, context));\n\t\t\tsequence = new Sequence([sequence, afterAlwaysHooks], false);\n\t\t}\n\t\treturn sequence;\n\t}\n\n\t_buildTests(tests) {\n\t\treturn tests.map(test => this._buildTestWithHooks(test));\n\t}\n\n\t_hasUnskippedTests() {\n\t\treturn this.tests.serial.concat(this.tests.concurrent)\n\t\t\t.some(test => {\n\t\t\t\treturn !(test.metadata && test.metadata.skipped === true);\n\t\t\t});\n\t}\n\n\tbuild() {\n\t\tconst serialTests = new Sequence(this._buildTests(this.tests.serial), this.bail);\n\t\tconst concurrentTests = new Concurrent(this._buildTests(this.tests.concurrent), this.bail);\n\t\tconst allTests = new Sequence([serialTests, concurrentTests]);\n\n\t\tlet finalTests;\n\t\t// Only run before and after hooks when there are unskipped tests\n\t\tif (this._hasUnskippedTests()) {\n\t\t\tconst beforeHooks = new Sequence(this._buildHooks(this.hooks.before));\n\t\t\tconst afterHooks = new Sequence(this._buildHooks(this.hooks.after));\n\t\t\tfinalTests = new Sequence([beforeHooks, allTests, afterHooks], true);\n\t\t} else {\n\t\t\tfinalTests = new Sequence([allTests], true);\n\t\t}\n\n\t\tif (this.hooks.afterAlways.length > 0) {\n\t\t\tconst afterAlwaysHooks = new Sequence(this._buildHooks(this.hooks.afterAlways));\n\t\t\tfinalTests = new Sequence([finalTests, afterAlwaysHooks], false);\n\t\t}\n\n\t\treturn finalTests;\n\t}\n\n\tattributeLeakedError(err) {\n\t\tfor (const test of this.pendingTestInstances) {\n\t\t\tif (test.attributeLeakedError(err)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nmodule.exports = TestCollection;\n"},"hash":"4edf1ff1c24f8502ca8d987cc57e3801"}