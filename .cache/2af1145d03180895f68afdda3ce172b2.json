{"dependencies":[{"name":"./test-worker","loc":{"line":2,"column":23}},{"name":"./process-adapter","loc":{"line":3,"column":24}},{"name":"./serialize-error","loc":{"line":4,"column":31}},{"name":"./globals","loc":{"line":5,"column":24}},{"name":"./runner","loc":{"line":6,"column":23}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\nconst worker = require('./test-worker');\nconst adapter = require('./process-adapter');\nconst serializeError = require('./serialize-error');\nconst globals = require('./globals');\nconst Runner = require('./runner');\n\nconst opts = globals.options;\nconst runner = new Runner({\n\tbail: opts.failFast,\n\tfailWithoutAssertions: opts.failWithoutAssertions,\n\tfile: opts.file,\n\tmatch: opts.match,\n\tprojectDir: opts.projectDir,\n\tserial: opts.serial,\n\tupdateSnapshots: opts.updateSnapshots,\n\tsnapshotDir: opts.snapshotDir\n});\n\nworker.setRunner(runner);\n\n// If fail-fast is enabled, use this variable to detect\n// that no more tests should be logged\nlet isFailed = false;\n\nError.stackTraceLimit = Infinity;\n\nfunction test(props) {\n\tif (isFailed) {\n\t\treturn;\n\t}\n\n\tconst hasError = typeof props.error !== 'undefined';\n\n\t// Don't display anything if it's a passed hook\n\tif (!hasError && props.type !== 'test') {\n\t\treturn;\n\t}\n\n\tif (hasError) {\n\t\tprops.error = serializeError(props.error);\n\t} else {\n\t\tprops.error = null;\n\t}\n\n\tadapter.send('test', props);\n\n\tif (hasError && opts.failFast) {\n\t\tisFailed = true;\n\t\texit();\n\t}\n}\n\nfunction exit() {\n\t// Reference the IPC channel now that tests have finished running.\n\tadapter.ipcChannel.ref();\n\n\tconst stats = runner.buildStats();\n\tadapter.send('results', {stats});\n}\n\nglobals.setImmediate(() => {\n\tconst hasExclusive = runner.tests.hasExclusive;\n\tconst numberOfTests = runner.tests.testCount;\n\n\tif (numberOfTests === 0) {\n\t\tadapter.send('no-tests', {avaRequired: true});\n\t\treturn;\n\t}\n\n\tadapter.send('stats', {\n\t\ttestCount: numberOfTests,\n\t\thasExclusive\n\t});\n\n\trunner.on('test', test);\n\n\tprocess.on('ava-run', options => {\n\t\t// Unreference the IPC channel. This stops it from keeping the event loop\n\t\t// busy, which means the `beforeExit` event can be used to detect when tests\n\t\t// stall.\n\t\tadapter.ipcChannel.unref();\n\n\t\trunner.run(options)\n\t\t\t.then(() => {\n\t\t\t\trunner.saveSnapshotState();\n\n\t\t\t\treturn exit();\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tprocess.emit('uncaughtException', err);\n\t\t\t});\n\t});\n\n\tprocess.on('ava-init-exit', () => {\n\t\texit();\n\t});\n});\n\nmodule.exports = runner.chain;\n\n// TypeScript imports the `default` property for\n// an ES2015 default import (`import test from 'ava'`)\n// See: https://github.com/Microsoft/TypeScript/issues/2242#issuecomment-83694181\nmodule.exports.default = runner.chain;\n"},"hash":"e89a7ba0aa9c542e8e23c9ac03b66bc8"}