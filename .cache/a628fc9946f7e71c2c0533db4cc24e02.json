{"dependencies":[{"name":"events","loc":{"line":2,"column":29}},{"name":"path","loc":{"line":3,"column":21}},{"name":"bluebird","loc":{"line":4,"column":25}},{"name":"option-chain","loc":{"line":5,"column":28}},{"name":"matcher","loc":{"line":6,"column":24}},{"name":"./snapshot-manager","loc":{"line":7,"column":32}},{"name":"./test-collection","loc":{"line":8,"column":31}},{"name":"./validate-test","loc":{"line":9,"column":29}}],"generated":{"js":"'use strict';\nconst EventEmitter = require('events');\nconst path = require('path');\nconst Bluebird = require('bluebird');\nconst optionChain = require('option-chain');\nconst matcher = require('matcher');\nconst snapshotManager = require('./snapshot-manager');\nconst TestCollection = require('./test-collection');\nconst validateTest = require('./validate-test');\n\nconst chainableMethods = {\n\tdefaults: {\n\t\ttype: 'test',\n\t\tserial: false,\n\t\texclusive: false,\n\t\tskipped: false,\n\t\ttodo: false,\n\t\tfailing: false,\n\t\tcallback: false,\n\t\talways: false\n\t},\n\tchainableMethods: {\n\t\ttest: {},\n\t\tserial: {serial: true},\n\t\tbefore: {type: 'before'},\n\t\tafter: {type: 'after'},\n\t\tskip: {skipped: true},\n\t\ttodo: {todo: true},\n\t\tfailing: {failing: true},\n\t\tonly: {exclusive: true},\n\t\tbeforeEach: {type: 'beforeEach'},\n\t\tafterEach: {type: 'afterEach'},\n\t\tcb: {callback: true},\n\t\talways: {always: true}\n\t}\n};\n\nfunction wrapFunction(fn, args) {\n\treturn function (t) {\n\t\treturn fn.apply(this, [t].concat(args));\n\t};\n}\n\nclass Runner extends EventEmitter {\n\tconstructor(options) {\n\t\tsuper();\n\n\t\toptions = options || {};\n\n\t\tthis.file = options.file;\n\t\tthis.match = options.match || [];\n\t\tthis.projectDir = options.projectDir;\n\t\tthis.serial = options.serial;\n\t\tthis.updateSnapshots = options.updateSnapshots;\n\t\tthis.snapshotDir = options.snapshotDir;\n\n\t\tthis.hasStarted = false;\n\t\tthis.results = [];\n\t\tthis.snapshots = null;\n\t\tthis.tests = new TestCollection({\n\t\t\tbail: options.bail,\n\t\t\tfailWithoutAssertions: options.failWithoutAssertions,\n\t\t\tcompareTestSnapshot: this.compareTestSnapshot.bind(this)\n\t\t});\n\n\t\tthis.chain = optionChain(chainableMethods, (opts, args) => {\n\t\t\tlet title;\n\t\t\tlet fn;\n\t\t\tlet macroArgIndex;\n\n\t\t\tif (this.hasStarted) {\n\t\t\t\tthrow new Error('All tests and hooks must be declared synchronously in your ' +\n\t\t\t\t'test file, and cannot be nested within other tests or hooks.');\n\t\t\t}\n\n\t\t\tif (typeof args[0] === 'string') {\n\t\t\t\ttitle = args[0];\n\t\t\t\tfn = args[1];\n\t\t\t\tmacroArgIndex = 2;\n\t\t\t} else {\n\t\t\t\tfn = args[0];\n\t\t\t\ttitle = null;\n\t\t\t\tmacroArgIndex = 1;\n\t\t\t}\n\n\t\t\tif (this.serial) {\n\t\t\t\topts.serial = true;\n\t\t\t}\n\n\t\t\tif (args.length > macroArgIndex) {\n\t\t\t\targs = args.slice(macroArgIndex);\n\t\t\t} else {\n\t\t\t\targs = null;\n\t\t\t}\n\n\t\t\tif (Array.isArray(fn)) {\n\t\t\t\tfn.forEach(fn => {\n\t\t\t\t\tthis.addTest(title, opts, fn, args);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.addTest(title, opts, fn, args);\n\t\t\t}\n\t\t});\n\t}\n\n\taddTest(title, metadata, fn, args) {\n\t\tif (args) {\n\t\t\tif (fn.title) {\n\t\t\t\ttitle = fn.title.apply(fn, [title || ''].concat(args));\n\t\t\t}\n\n\t\t\tfn = wrapFunction(fn, args);\n\t\t}\n\n\t\tif (metadata.type === 'test' && this.match.length > 0) {\n\t\t\tmetadata.exclusive = matcher([title || ''], this.match).length === 1;\n\t\t}\n\n\t\tconst validationError = validateTest(title, fn, metadata);\n\t\tif (validationError !== null) {\n\t\t\tthrow new TypeError(validationError);\n\t\t}\n\n\t\tthis.tests.add({\n\t\t\tmetadata,\n\t\t\tfn,\n\t\t\ttitle\n\t\t});\n\t}\n\n\taddTestResult(result) {\n\t\tconst test = result.result;\n\t\tconst props = {\n\t\t\tlogs: test.logs,\n\t\t\tduration: test.duration,\n\t\t\ttitle: test.title,\n\t\t\terror: result.reason,\n\t\t\ttype: test.metadata.type,\n\t\t\tskip: test.metadata.skipped,\n\t\t\ttodo: test.metadata.todo,\n\t\t\tfailing: test.metadata.failing\n\t\t};\n\n\t\tthis.results.push(result);\n\t\tthis.emit('test', props);\n\t}\n\n\tbuildStats() {\n\t\tconst stats = {\n\t\t\tfailCount: 0,\n\t\t\tknownFailureCount: 0,\n\t\t\tpassCount: 0,\n\t\t\tskipCount: 0,\n\t\t\ttestCount: 0,\n\t\t\ttodoCount: 0\n\t\t};\n\n\t\tfor (const result of this.results) {\n\t\t\tif (!result.passed) {\n\t\t\t\t// Includes hooks\n\t\t\t\tstats.failCount++;\n\t\t\t}\n\n\t\t\tconst metadata = result.result.metadata;\n\t\t\tif (metadata.type === 'test') {\n\t\t\t\tstats.testCount++;\n\n\t\t\t\tif (metadata.skipped) {\n\t\t\t\t\tstats.skipCount++;\n\t\t\t\t} else if (metadata.todo) {\n\t\t\t\t\tstats.todoCount++;\n\t\t\t\t} else if (result.passed) {\n\t\t\t\t\tif (metadata.failing) {\n\t\t\t\t\t\tstats.knownFailureCount++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstats.passCount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stats;\n\t}\n\n\tcompareTestSnapshot(options) {\n\t\tif (!this.snapshots) {\n\t\t\tthis.snapshots = snapshotManager.load({\n\t\t\t\tfile: this.file,\n\t\t\t\tfixedLocation: this.snapshotDir,\n\t\t\t\tname: path.basename(this.file),\n\t\t\t\tprojectDir: this.projectDir,\n\t\t\t\trelFile: path.relative(this.projectDir, this.file),\n\t\t\t\ttestDir: path.dirname(this.file),\n\t\t\t\tupdating: this.updateSnapshots\n\t\t\t});\n\t\t\tthis.emit('dependency', this.snapshots.snapPath);\n\t\t}\n\n\t\treturn this.snapshots.compare(options);\n\t}\n\n\tsaveSnapshotState() {\n\t\tif (this.snapshots) {\n\t\t\tconst files = this.snapshots.save();\n\t\t\tif (files) {\n\t\t\t\tthis.emit('touched', files);\n\t\t\t}\n\t\t} else if (this.updateSnapshots) {\n\t\t\t// TODO: There may be unused snapshot files if no test caused the\n\t\t\t// snapshots to be loaded. Prune them. But not if tests (including hooks!)\n\t\t\t// were skipped. Perhaps emit a warning if this occurs?\n\t\t}\n\t}\n\n\trun(options) {\n\t\tif (options.runOnlyExclusive && !this.tests.hasExclusive) {\n\t\t\treturn Promise.resolve(null);\n\t\t}\n\n\t\tthis.hasStarted = true;\n\t\tthis.tests.on('test', result => {\n\t\t\tthis.addTestResult(result);\n\t\t});\n\t\treturn Bluebird.try(() => this.tests.build().run());\n\t}\n\n\tattributeLeakedError(err) {\n\t\treturn this.tests.attributeLeakedError(err);\n\t}\n}\n\nmodule.exports = Runner;\n"},"hash":"e86ab0425195445ff9ce1ac72f1e8d72"}