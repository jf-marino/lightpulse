{"dependencies":[{"name":"is-generator-fn","loc":{"line":2,"column":30}},{"name":"co-with-promise","loc":{"line":3,"column":19}},{"name":"concordance","loc":{"line":4,"column":28}},{"name":"observable-to-promise","loc":{"line":5,"column":36}},{"name":"is-promise","loc":{"line":6,"column":26}},{"name":"is-observable","loc":{"line":7,"column":29}},{"name":"plur","loc":{"line":8,"column":21}},{"name":"./assert","loc":{"line":9,"column":23}},{"name":"./globals","loc":{"line":10,"column":24}},{"name":"./concordance-options","loc":{"line":11,"column":35}}],"generated":{"js":"'use strict';\nconst isGeneratorFn = require('is-generator-fn');\nconst co = require('co-with-promise');\nconst concordance = require('concordance');\nconst observableToPromise = require('observable-to-promise');\nconst isPromise = require('is-promise');\nconst isObservable = require('is-observable');\nconst plur = require('plur');\nconst assert = require('./assert');\nconst globals = require('./globals');\nconst concordanceOptions = require('./concordance-options').default;\n\nfunction formatErrorValue(label, error) {\n\tconst formatted = concordance.format(error, concordanceOptions);\n\treturn {label, formatted};\n}\n\nclass SkipApi {\n\tconstructor(test) {\n\t\tthis._test = test;\n\t}\n}\n\nconst captureStack = start => {\n\tconst limitBefore = Error.stackTraceLimit;\n\tError.stackTraceLimit = 1;\n\tconst obj = {};\n\tError.captureStackTrace(obj, start);\n\tError.stackTraceLimit = limitBefore;\n\treturn obj.stack;\n};\n\nclass ExecutionContext {\n\tconstructor(test) {\n\t\tObject.defineProperties(this, {\n\t\t\t_test: {value: test},\n\t\t\tskip: {value: new SkipApi(test)}\n\t\t});\n\t}\n\n\tplan(ct) {\n\t\tthis._test.plan(ct, captureStack(this.plan));\n\t}\n\n\tget end() {\n\t\tconst end = this._test.bindEndCallback();\n\t\tconst endFn = err => end(err, captureStack(endFn));\n\t\treturn endFn;\n\t}\n\n\tget title() {\n\t\treturn this._test.title;\n\t}\n\n\tget context() {\n\t\tconst contextRef = this._test.contextRef;\n\t\treturn contextRef && contextRef.context;\n\t}\n\n\tset context(context) {\n\t\tconst contextRef = this._test.contextRef;\n\n\t\tif (!contextRef) {\n\t\t\tthis._test.saveFirstError(new Error(`\\`t.context\\` is not available in ${this._test.metadata.type} tests`));\n\t\t\treturn;\n\t\t}\n\n\t\tcontextRef.context = context;\n\t}\n\n\t_throwsArgStart(assertion, file, line) {\n\t\tthis._test.trackThrows({assertion, file, line});\n\t}\n\n\t_throwsArgEnd() {\n\t\tthis._test.trackThrows(null);\n\t}\n}\n\n{\n\tconst assertions = assert.wrapAssertions({\n\t\tlog(executionContext, text) {\n\t\t\texecutionContext._test.addLog(text);\n\t\t},\n\n\t\tpass(executionContext) {\n\t\t\texecutionContext._test.countPassedAssertion();\n\t\t},\n\n\t\tpending(executionContext, promise) {\n\t\t\texecutionContext._test.addPendingAssertion(promise);\n\t\t},\n\n\t\tfail(executionContext, error) {\n\t\t\texecutionContext._test.addFailedAssertion(error);\n\t\t}\n\t});\n\tObject.assign(ExecutionContext.prototype, assertions);\n\n\tfunction skipFn() {\n\t\tthis._test.countPassedAssertion();\n\t}\n\tObject.keys(assertions).forEach(el => {\n\t\tSkipApi.prototype[el] = skipFn;\n\t});\n}\n\nclass Test {\n\tconstructor(options) {\n\t\tthis.contextRef = options.contextRef;\n\t\tthis.failWithoutAssertions = options.failWithoutAssertions;\n\t\tthis.fn = isGeneratorFn(options.fn) ? co.wrap(options.fn) : options.fn;\n\t\tthis.metadata = options.metadata;\n\t\tthis.onResult = options.onResult;\n\t\tthis.title = options.title;\n\t\tthis.logs = [];\n\n\t\tthis.snapshotInvocationCount = 0;\n\t\tthis.compareWithSnapshot = assertionOptions => {\n\t\t\tconst belongsTo = assertionOptions.id || this.title;\n\t\t\tconst expected = assertionOptions.expected;\n\t\t\tconst index = assertionOptions.id ? 0 : this.snapshotInvocationCount++;\n\t\t\tconst label = assertionOptions.id ? '' : assertionOptions.message || `Snapshot ${this.snapshotInvocationCount}`;\n\t\t\treturn options.compareTestSnapshot({belongsTo, expected, index, label});\n\t\t};\n\n\t\tthis.assertCount = 0;\n\t\tthis.assertError = undefined;\n\t\tthis.calledEnd = false;\n\t\tthis.duration = null;\n\t\tthis.endCallbackFinisher = null;\n\t\tthis.finishDueToAttributedError = null;\n\t\tthis.finishDueToInactivity = null;\n\t\tthis.finishing = false;\n\t\tthis.pendingAssertionCount = 0;\n\t\tthis.pendingThrowsAssertion = null;\n\t\tthis.planCount = null;\n\t\tthis.startedAt = 0;\n\t}\n\n\tbindEndCallback() {\n\t\tif (this.metadata.callback) {\n\t\t\treturn (err, stack) => {\n\t\t\t\tthis.endCallback(err, stack);\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error('`t.end()`` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`');\n\t}\n\n\tendCallback(err, stack) {\n\t\tif (this.calledEnd) {\n\t\t\tthis.saveFirstError(new Error('`t.end()` called more than once'));\n\t\t\treturn;\n\t\t}\n\t\tthis.calledEnd = true;\n\n\t\tif (err) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tactual: err,\n\t\t\t\tmessage: 'Callback called with an error',\n\t\t\t\tstack,\n\t\t\t\tvalues: [formatErrorValue('Callback called with an error:', err)]\n\t\t\t}));\n\t\t}\n\n\t\tif (this.endCallbackFinisher) {\n\t\t\tthis.endCallbackFinisher();\n\t\t}\n\t}\n\n\tcreateExecutionContext() {\n\t\treturn new ExecutionContext(this);\n\t}\n\n\tcountPassedAssertion() {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t}\n\n\taddLog(text) {\n\t\tthis.logs.push(text);\n\t}\n\n\taddPendingAssertion(promise) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion passed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.pendingAssertionCount++;\n\t\tpromise\n\t\t\t.catch(err => this.saveFirstError(err))\n\t\t\t.then(() => this.pendingAssertionCount--);\n\t}\n\n\taddFailedAssertion(error) {\n\t\tif (this.finishing) {\n\t\t\tthis.saveFirstError(new Error('Assertion failed, but test has already finished'));\n\t\t}\n\n\t\tthis.assertCount++;\n\t\tthis.saveFirstError(error);\n\t}\n\n\tsaveFirstError(err) {\n\t\tif (!this.assertError) {\n\t\t\tthis.assertError = err;\n\t\t}\n\t}\n\n\tplan(count, planStack) {\n\t\tif (typeof count !== 'number') {\n\t\t\tthrow new TypeError('Expected a number');\n\t\t}\n\n\t\tthis.planCount = count;\n\n\t\t// In case the `planCount` doesn't match `assertCount, we need the stack of\n\t\t// this function to throw with a useful stack.\n\t\tthis.planStack = planStack;\n\t}\n\n\tverifyPlan() {\n\t\tif (!this.assertError && this.planCount !== null && this.planCount !== this.assertCount) {\n\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\tassertion: 'plan',\n\t\t\t\tmessage: `Planned for ${this.planCount} ${plur('assertion', this.planCount)}, but got ${this.assertCount}.`,\n\t\t\t\toperator: '===',\n\t\t\t\tstack: this.planStack\n\t\t\t}));\n\t\t}\n\t}\n\n\tverifyAssertions() {\n\t\tif (!this.assertError) {\n\t\t\tif (this.failWithoutAssertions && !this.calledEnd && this.planCount === null && this.assertCount === 0) {\n\t\t\t\tthis.saveFirstError(new Error('Test finished without running any assertions'));\n\t\t\t} else if (this.pendingAssertionCount > 0) {\n\t\t\t\tthis.saveFirstError(new Error('Test finished, but an assertion is still pending'));\n\t\t\t}\n\t\t}\n\t}\n\n\ttrackThrows(pending) {\n\t\tthis.pendingThrowsAssertion = pending;\n\t}\n\n\tdetectImproperThrows(err) {\n\t\tif (!this.pendingThrowsAssertion) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst pending = this.pendingThrowsAssertion;\n\t\tthis.pendingThrowsAssertion = null;\n\n\t\tconst values = [];\n\t\tif (err) {\n\t\t\tvalues.push(formatErrorValue(`The following error was thrown, possibly before \\`t.${pending.assertion}()\\` could be called:`, err));\n\t\t}\n\n\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\tassertion: pending.assertion,\n\t\t\tfixedSource: {file: pending.file, line: pending.line},\n\t\t\timproperUsage: true,\n\t\t\tmessage: `Improper usage of \\`t.${pending.assertion}()\\` detected`,\n\t\t\tstack: err instanceof Error && err.stack,\n\t\t\tvalues\n\t\t}));\n\t\treturn true;\n\t}\n\n\twaitForPendingThrowsAssertion() {\n\t\treturn new Promise(resolve => {\n\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\tresolve(this.finishPromised());\n\t\t\t};\n\n\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\tthis.detectImproperThrows();\n\t\t\t\tresolve(this.finishPromised());\n\t\t\t};\n\n\t\t\t// Wait up to a second to see if an error can be attributed to the\n\t\t\t// pending assertion.\n\t\t\tglobals.setTimeout(() => this.finishDueToInactivity(), 1000).unref();\n\t\t});\n\t}\n\n\tattributeLeakedError(err) {\n\t\tif (!this.detectImproperThrows(err)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.finishDueToAttributedError();\n\t\treturn true;\n\t}\n\n\tcallFn() {\n\t\ttry {\n\t\t\treturn {\n\t\t\t\tok: true,\n\t\t\t\tretval: this.fn(this.createExecutionContext())\n\t\t\t};\n\t\t} catch (err) {\n\t\t\treturn {\n\t\t\t\tok: false,\n\t\t\t\terror: err\n\t\t\t};\n\t\t}\n\t}\n\n\trun() {\n\t\tthis.startedAt = globals.now();\n\n\t\tconst result = this.callFn();\n\t\tif (!result.ok) {\n\t\t\tif (!this.detectImproperThrows(result.error)) {\n\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\tmessage: 'Error thrown in test',\n\t\t\t\t\tstack: result.error instanceof Error && result.error.stack,\n\t\t\t\t\tvalues: [formatErrorValue('Error thrown in test:', result.error)]\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn this.finish();\n\t\t}\n\n\t\tconst returnedObservable = isObservable(result.retval);\n\t\tconst returnedPromise = isPromise(result.retval);\n\n\t\tlet promise;\n\t\tif (returnedObservable) {\n\t\t\tpromise = observableToPromise(result.retval);\n\t\t} else if (returnedPromise) {\n\t\t\t// `retval` can be any thenable, so convert to a proper promise.\n\t\t\tpromise = Promise.resolve(result.retval);\n\t\t}\n\n\t\tif (this.metadata.callback) {\n\t\t\tif (returnedObservable || returnedPromise) {\n\t\t\t\tconst asyncType = returnedObservable ? 'observables' : 'promises';\n\t\t\t\tthis.saveFirstError(new Error(`Do not return ${asyncType} from tests declared via \\`test.cb(...)\\`, if you want to return a promise simply declare the test via \\`test(...)\\``));\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\tif (this.calledEnd) {\n\t\t\t\treturn this.finish();\n\t\t\t}\n\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.endCallbackFinisher = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tthis.saveFirstError(new Error('`t.end()` was never called'));\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\tif (promise) {\n\t\t\treturn new Promise(resolve => {\n\t\t\t\tthis.finishDueToAttributedError = () => {\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tthis.finishDueToInactivity = () => {\n\t\t\t\t\tconst err = returnedObservable ?\n\t\t\t\t\t\tnew Error('Observable returned by test never completed') :\n\t\t\t\t\t\tnew Error('Promise returned by test never resolved');\n\t\t\t\t\tthis.saveFirstError(err);\n\t\t\t\t\tresolve(this.finishPromised());\n\t\t\t\t};\n\n\t\t\t\tpromise\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tif (!this.detectImproperThrows(err)) {\n\t\t\t\t\t\t\tthis.saveFirstError(new assert.AssertionError({\n\t\t\t\t\t\t\t\tmessage: 'Rejected promise returned by test',\n\t\t\t\t\t\t\t\tstack: err instanceof Error && err.stack,\n\t\t\t\t\t\t\t\tvalues: [formatErrorValue('Rejected promise returned by test. Reason:', err)]\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.then(() => resolve(this.finishPromised()));\n\t\t\t});\n\t\t}\n\n\t\treturn this.finish();\n\t}\n\n\tfinish() {\n\t\tthis.finishing = true;\n\n\t\tif (!this.assertError && this.pendingThrowsAssertion) {\n\t\t\treturn this.waitForPendingThrowsAssertion();\n\t\t}\n\n\t\tthis.verifyPlan();\n\t\tthis.verifyAssertions();\n\n\t\tthis.duration = globals.now() - this.startedAt;\n\n\t\tlet reason = this.assertError;\n\t\tlet passed = !reason;\n\n\t\tif (this.metadata.failing) {\n\t\t\tpassed = !passed;\n\n\t\t\tif (passed) {\n\t\t\t\treason = undefined;\n\t\t\t} else {\n\t\t\t\treason = new Error('Test was expected to fail, but succeeded, you should stop marking the test as failing');\n\t\t\t}\n\t\t}\n\n\t\tthis.onResult({\n\t\t\tpassed,\n\t\t\tresult: this,\n\t\t\treason\n\t\t});\n\n\t\treturn passed;\n\t}\n\n\tfinishPromised() {\n\t\treturn new Promise(resolve => {\n\t\t\tresolve(this.finish());\n\t\t});\n\t}\n}\n\nmodule.exports = Test;\n"},"hash":"3df745b8d715d309303f846acf27ac89"}