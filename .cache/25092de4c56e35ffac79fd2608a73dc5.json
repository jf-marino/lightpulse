{"dependencies":[{"name":"./constants","loc":{"line":3,"column":26}},{"name":"./recursorUtils","loc":{"line":4,"column":30}}],"generated":{"js":"'use strict'\n\nconst constants = require('./constants')\nconst recursorUtils = require('./recursorUtils')\n\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst SHALLOW_EQUAL = constants.SHALLOW_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nclass Comparable {\n  constructor (properties) {\n    this.properties = properties\n    this.ordered = properties.slice()\n  }\n\n  createRecursor () {\n    const length = this.ordered.length\n    let index = 0\n    return () => {\n      if (index === length) return null\n\n      return this.ordered[index++]\n    }\n  }\n\n  compare (expected) {\n    if (this.properties.length !== expected.properties.length) return UNEQUAL\n\n    // Compare property keys, reordering the expected properties in the process\n    // so values can be compared if all keys are equal.\n    const ordered = []\n    const processed = new Set()\n    for (const property of this.properties) {\n      let extraneous = true\n      for (const other of expected.properties) {\n        if (processed.has(other.key)) continue\n\n        if (property.key.compare(other.key) === DEEP_EQUAL) {\n          extraneous = false\n          processed.add(other.key)\n          ordered.push(other)\n          break\n        }\n      }\n\n      if (extraneous) return UNEQUAL\n    }\n    expected.ordered = ordered\n\n    return SHALLOW_EQUAL\n  }\n\n  prepareDiff (expected) {\n    // Reorder the expected properties before recursion starts.\n    const missingProperties = []\n    const ordered = []\n    const processed = new Set()\n    for (const other of expected.properties) {\n      let missing = true\n      for (const property of this.properties) {\n        if (processed.has(property.key)) continue\n\n        if (property.key.compare(other.key) === DEEP_EQUAL) {\n          missing = false\n          processed.add(property.key)\n          ordered.push(other)\n          break\n        }\n      }\n\n      if (missing) {\n        missingProperties.push(other)\n      }\n    }\n    expected.ordered = ordered.concat(missingProperties)\n\n    return {mustRecurse: true}\n  }\n}\nObject.defineProperty(Comparable.prototype, 'isSymbolPropertiesComparable', { value: true })\nexports.Comparable = Comparable\n\nclass Collector {\n  constructor (firstProperty, recursor) {\n    this.properties = [firstProperty]\n    this.recursor = recursor\n    this.remainder = null\n  }\n\n  collectAll () {\n    do {\n      const next = this.recursor()\n      if (next && next.isProperty === true) { // All properties will have symbol keys\n        this.properties.push(next)\n      } else {\n        return next\n      }\n    } while (true)\n  }\n\n  createRecursor () {\n    return recursorUtils.singleValue(new Comparable(this.properties))\n  }\n}\nObject.defineProperty(Collector.prototype, 'isSymbolPropertiesCollector', { value: true })\nexports.Collector = Collector\n"},"hash":"7a96a10b43a2e22418ad94d13a0e4ebc"}