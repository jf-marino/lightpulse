{"dependencies":[{"name":"js-string-escape","loc":{"line":3,"column":29}},{"name":"well-known-symbols","loc":{"line":4,"column":33}},{"name":"../constants","loc":{"line":6,"column":26}},{"name":"../formatUtils","loc":{"line":7,"column":28}},{"name":"../lineBuilder","loc":{"line":8,"column":28}}],"generated":{"js":"'use strict'\n\nconst stringEscape = require('js-string-escape')\nconst wellKnownSymbols = require('well-known-symbols')\n\nconst constants = require('../constants')\nconst formatUtils = require('../formatUtils')\nconst lineBuilder = require('../lineBuilder')\n\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nfunction describe (value) {\n  let stringCompare = null\n\n  const key = Symbol.keyFor(value)\n  if (key !== undefined) {\n    stringCompare = `Symbol.for(${stringEscape(key)})`\n  } else if (wellKnownSymbols.isWellKnown(value)) {\n    stringCompare = wellKnownSymbols.getLabel(value)\n  }\n\n  return new SymbolValue({\n    stringCompare,\n    value\n  })\n}\nexports.describe = describe\n\nfunction deserialize (state) {\n  const stringCompare = state[0]\n  const string = state[1] || state[0]\n\n  return new DeserializedSymbolValue({\n    string,\n    stringCompare,\n    value: null\n  })\n}\nexports.deserialize = deserialize\n\nconst tag = Symbol('SymbolValue')\nexports.tag = tag\n\nclass SymbolValue {\n  constructor (props) {\n    this.stringCompare = props.stringCompare\n    this.value = props.value\n  }\n\n  compare (expected) {\n    if (expected.tag !== tag) return UNEQUAL\n\n    if (this.stringCompare !== null) {\n      return this.stringCompare === expected.stringCompare\n        ? DEEP_EQUAL\n        : UNEQUAL\n    }\n\n    return this.value === expected.value\n      ? DEEP_EQUAL\n      : UNEQUAL\n  }\n\n  formatString () {\n    if (this.stringCompare !== null) return this.stringCompare\n    return stringEscape(this.value.toString())\n  }\n\n  formatDeep (theme) {\n    return lineBuilder.single(formatUtils.wrap(theme.symbol, this.formatString()))\n  }\n\n  formatAsKey (theme) {\n    return formatUtils.wrap(theme.property.keyBracket, formatUtils.wrap(theme.symbol, this.formatString()))\n  }\n\n  serialize () {\n    const string = this.formatString()\n    return this.stringCompare === string\n      ? [this.stringCompare]\n      : [this.stringCompare, string]\n  }\n}\nObject.defineProperty(SymbolValue.prototype, 'isPrimitive', { value: true })\nObject.defineProperty(SymbolValue.prototype, 'tag', { value: tag })\n\nclass DeserializedSymbolValue extends SymbolValue {\n  constructor (props) {\n    super(props)\n    this.string = props.string\n  }\n\n  compare (expected) {\n    if (expected.tag !== tag) return UNEQUAL\n\n    if (this.stringCompare !== null) {\n      return this.stringCompare === expected.stringCompare\n        ? DEEP_EQUAL\n        : UNEQUAL\n    }\n\n    // Symbols that are not in the global symbol registry, and are not\n    // well-known, cannot be compared when deserialized. Treat symbols\n    // as equal if they are formatted the same.\n    return this.string === expected.formatString()\n      ? DEEP_EQUAL\n      : UNEQUAL\n  }\n\n  formatString () {\n    return this.string\n  }\n}\n"},"hash":"29ea512769881501d3430d32e6865bb8"}