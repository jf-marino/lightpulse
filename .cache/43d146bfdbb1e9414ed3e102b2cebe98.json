{"dependencies":[{"name":"./constants","loc":{"line":3,"column":26}},{"name":"./describe","loc":{"line":4,"column":25}},{"name":"./recursorUtils","loc":{"line":5,"column":30}},{"name":"./shouldCompareDeep","loc":{"line":6,"column":34}},{"name":"./symbolProperties","loc":{"line":7,"column":33}},{"name":"./Circular","loc":{"line":8,"column":25}}],"generated":{"js":"'use strict'\n\nconst constants = require('./constants')\nconst describe = require('./describe')\nconst recursorUtils = require('./recursorUtils')\nconst shouldCompareDeep = require('./shouldCompareDeep')\nconst symbolProperties = require('./symbolProperties')\nconst Circular = require('./Circular')\n\nconst AMBIGUOUS = constants.AMBIGUOUS\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nfunction shortcircuitPrimitive (value) {\n  if (value === null || value === undefined || value === true || value === false) return true\n\n  const type = typeof value\n  if (type === 'string' || type === 'symbol') return true\n  // Don't shortcircuit NaN values\n  if (type === 'number') return !isNaN(value)\n\n  return false\n}\n\nfunction compareDescriptors (lhs, rhs) {\n  const lhsCircular = new Circular()\n  const rhsCircular = new Circular()\n\n  const lhsStack = []\n  const rhsStack = []\n  let topIndex = -1\n\n  do {\n    let result\n    if (lhsCircular.has(lhs)) {\n      result = lhsCircular.get(lhs) === rhsCircular.get(rhs)\n        ? DEEP_EQUAL\n        : UNEQUAL\n    } else if (rhsCircular.has(rhs)) {\n      result = UNEQUAL\n    } else {\n      result = lhs.compare(rhs)\n    }\n\n    if (result === UNEQUAL) return false\n    if (result !== DEEP_EQUAL) {\n      if (!shouldCompareDeep(result, lhs, rhs)) return false\n\n      if (result === AMBIGUOUS && lhs.isProperty === true) {\n        // Replace both sides by a pseudo-descriptor which collects symbol\n        // properties instead.\n        lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor)\n        rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor)\n        // Replace the current recursors so they can continue correctly after\n        // the collectors have been \"compared\". This is necessary since the\n        // collectors eat the first value after the last symbol property.\n        lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll())\n        rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll())\n      }\n\n      lhsCircular.add(lhs)\n      rhsCircular.add(rhs)\n\n      lhsStack.push({ subject: lhs, recursor: lhs.createRecursor() })\n      rhsStack.push({ subject: rhs, recursor: rhs.createRecursor() })\n      topIndex++\n    }\n\n    while (topIndex >= 0) {\n      lhs = lhsStack[topIndex].recursor()\n      rhs = rhsStack[topIndex].recursor()\n      if (lhs !== null && rhs !== null) {\n        break\n      }\n\n      if (lhs === null && rhs === null) {\n        const lhsRecord = lhsStack.pop()\n        const rhsRecord = rhsStack.pop()\n        lhsCircular.delete(lhsRecord.subject)\n        rhsCircular.delete(rhsRecord.subject)\n        topIndex--\n      } else {\n        return false\n      }\n    }\n  } while (topIndex >= 0)\n\n  return true\n}\nexports.compareDescriptors = compareDescriptors\n\nfunction compare (actual, expected, options) {\n  if (Object.is(actual, expected)) return { pass: true }\n  // Primitive values should be the same, so if actual or expected is primitive\n  // then the values will never compare.\n  if (shortcircuitPrimitive(actual) || shortcircuitPrimitive(expected)) return { pass: false }\n\n  actual = describe(actual, options)\n  expected = describe(expected, options)\n  const pass = compareDescriptors(actual, expected)\n  return { actual, expected, pass }\n}\nexports.compare = compare\n"},"hash":"8154a6a59b2a25c7a961e7ad3146e677"}