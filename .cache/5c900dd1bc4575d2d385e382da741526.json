{"dependencies":[{"name":"../constants","loc":{"line":3,"column":26}},{"name":"../formatUtils","loc":{"line":4,"column":28}},{"name":"../recursorUtils","loc":{"line":5,"column":30}},{"name":"../primitiveValues/symbol","loc":{"line":6,"column":32}}],"generated":{"js":"'use strict'\n\nconst constants = require('../constants')\nconst formatUtils = require('../formatUtils')\nconst recursorUtils = require('../recursorUtils')\nconst symbolPrimitive = require('../primitiveValues/symbol').tag\n\nconst AMBIGUOUS = constants.AMBIGUOUS\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nfunction describeComplex (key, value) {\n  return new ComplexProperty(key, value)\n}\nexports.describeComplex = describeComplex\n\nfunction deserializeComplex (key, recursor) {\n  const value = recursor()\n  return new ComplexProperty(key, value)\n}\nexports.deserializeComplex = deserializeComplex\n\nfunction describePrimitive (key, value) {\n  return new PrimitiveProperty(key, value)\n}\nexports.describePrimitive = describePrimitive\n\nfunction deserializePrimitive (state) {\n  const key = state[0]\n  const value = state[1]\n  return new PrimitiveProperty(key, value)\n}\nexports.deserializePrimitive = deserializePrimitive\n\nconst complexTag = Symbol('ComplexProperty')\nexports.complexTag = complexTag\n\nconst primitiveTag = Symbol('PrimitiveProperty')\nexports.primitiveTag = primitiveTag\n\nclass Property {\n  constructor (key) {\n    this.key = key\n  }\n\n  compareKeys (expected) {\n    const result = this.key.compare(expected.key)\n    // Return AMBIGUOUS if symbol keys are unequal. It's likely that properties\n    // are compared in order of declaration, which is not the desired strategy.\n    // Returning AMBIGUOUS allows compare() and diff() to recognize this\n    // situation and sort the symbol properties before comparing them.\n    return result === UNEQUAL && this.key.tag === symbolPrimitive && expected.key.tag === symbolPrimitive\n      ? AMBIGUOUS\n      : result\n  }\n\n  prepareDiff (expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {\n    // Circular values cannot be compared. They must be treated as being unequal when diffing.\n    if (isCircular(this.value) || isCircular(expected.value)) return {compareResult: UNEQUAL}\n\n    // Try to line up this or remaining properties with the expected properties.\n    const rhsFork = recursorUtils.fork(rhsRecursor)\n    const initialExpected = expected\n\n    do {\n      if (expected === null || expected.isProperty !== true) {\n        return {\n          actualIsExtraneous: true,\n          rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)\n        }\n      } else if (this.key.compare(expected.key) === DEEP_EQUAL) {\n        if (expected === initialExpected) {\n          return null\n        } else {\n          return {\n            expectedIsMissing: true,\n            lhsRecursor: recursorUtils.unshift(lhsRecursor, this),\n            rhsRecursor: rhsFork.recursor\n          }\n        }\n      }\n\n      expected = rhsFork.shared()\n    } while (true)\n  }\n}\nObject.defineProperty(Property.prototype, 'isProperty', { value: true })\n\nclass ComplexProperty extends Property {\n  constructor (key, value) {\n    super(key)\n    this.value = value\n  }\n\n  createRecursor () {\n    return recursorUtils.singleValue(this.value)\n  }\n\n  compare (expected) {\n    if (expected.isProperty !== true) return UNEQUAL\n\n    const keyResult = this.compareKeys(expected)\n    if (keyResult !== DEEP_EQUAL) return keyResult\n\n    return this.tag === expected.tag\n      ? this.value.compare(expected.value)\n      : UNEQUAL\n  }\n\n  formatShallow (theme, indent) {\n    const increaseValueIndent = theme.property.increaseValueIndent === true\n    return new formatUtils.SingleValueFormatter(theme, value => {\n      if (typeof theme.property.customFormat === 'function') {\n        return theme.property.customFormat(theme, indent, this.key, value)\n      }\n\n      return value\n        .withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator)\n        .withLastPostfixed(theme.property.after)\n    }, increaseValueIndent)\n  }\n\n  serialize () {\n    return this.key\n  }\n}\nObject.defineProperty(ComplexProperty.prototype, 'tag', { value: complexTag })\n\nclass PrimitiveProperty extends Property {\n  constructor (key, value) {\n    super(key)\n    this.value = value\n  }\n\n  compare (expected) {\n    if (expected.isProperty !== true) return UNEQUAL\n\n    const keyResult = this.compareKeys(expected)\n    if (keyResult !== DEEP_EQUAL) return keyResult\n\n    return this.tag !== expected.tag\n      ? UNEQUAL\n      : this.value.compare(expected.value)\n  }\n\n  formatDeep (theme, indent) {\n    const increaseValueIndent = theme.property.increaseValueIndent === true\n    const valueIndent = increaseValueIndent ? indent.increase() : indent\n\n    // Since the key and value are formatted directly, modifiers are not\n    // applied. Apply modifiers to the property descriptor instead.\n    const formatted = this.value.formatDeep(theme, valueIndent)\n\n    if (typeof theme.property.customFormat === 'function') {\n      return theme.property.customFormat(theme, indent, this.key, formatted)\n    }\n\n    return formatted\n      .withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator)\n      .withLastPostfixed(theme.property.after)\n  }\n\n  diffDeep (expected, theme, indent) {\n    // Verify a diff can be returned.\n    if (this.tag !== expected.tag || typeof this.value.diffDeep !== 'function') return null\n    // Only use this logic to diff values when the keys are the same.\n    if (this.key.compare(expected.key) !== DEEP_EQUAL) return null\n\n    const increaseValueIndent = theme.property.increaseValueIndent === true\n    const valueIndent = increaseValueIndent ? indent.increase() : indent\n\n    // Since the key and value are diffed directly, modifiers are not\n    // applied. Apply modifiers to the property descriptor instead.\n    const diff = this.value.diffDeep(expected.value, theme, valueIndent)\n    if (diff === null) return null\n\n    if (typeof theme.property.customFormat === 'function') {\n      return theme.property.customFormat(theme, indent, this.key, diff)\n    }\n\n    return diff\n      .withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator)\n      .withLastPostfixed(theme.property.after)\n  }\n\n  serialize () {\n    return [this.key, this.value]\n  }\n}\nObject.defineProperty(PrimitiveProperty.prototype, 'tag', { value: primitiveTag })\n"},"hash":"40070f308858ef802484004f7b1c8900"}