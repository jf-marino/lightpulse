{"dependencies":[{"name":"escape-string-regexp","loc":{"line":2,"column":35}}],"generated":{"js":"'use strict';\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst reCache = new Map();\n\nfunction makeRe(pattern, shouldNegate) {\n\tconst cacheKey = pattern + shouldNegate;\n\n\tif (reCache.has(cacheKey)) {\n\t\treturn reCache.get(cacheKey);\n\t}\n\n\tlet negated = false;\n\n\tif (pattern[0] === '!') {\n\t\tnegated = true;\n\t\tpattern = pattern.slice(1);\n\t}\n\n\tpattern = escapeStringRegexp(pattern).replace(/\\\\\\*/g, '.*');\n\n\tif (negated && shouldNegate) {\n\t\tpattern = `(?!${pattern})`;\n\t}\n\n\tconst re = new RegExp(`^${pattern}$`, 'i');\n\tre.negated = negated;\n\treCache.set(cacheKey, re);\n\n\treturn re;\n}\n\nmodule.exports = (inputs, patterns) => {\n\tif (!(Array.isArray(inputs) && Array.isArray(patterns))) {\n\t\tthrow new TypeError(`Expected two arrays, got ${typeof inputs} ${typeof patterns}`);\n\t}\n\n\tif (patterns.length === 0) {\n\t\treturn inputs;\n\t}\n\n\tconst firstNegated = patterns[0][0] === '!';\n\n\tpatterns = patterns.map(x => makeRe(x, false));\n\n\tconst ret = [];\n\n\tfor (const input of inputs) {\n\t\t// If first pattern is negated we include everything to match user expectation\n\t\tlet matches = firstNegated;\n\n\t\t// TODO: Figure out why tests fail when I use a for-of loop here\n\t\tfor (let j = 0; j < patterns.length; j++) {\n\t\t\tif (patterns[j].test(input)) {\n\t\t\t\tmatches = !patterns[j].negated;\n\t\t\t}\n\t\t}\n\n\t\tif (matches) {\n\t\t\tret.push(input);\n\t\t}\n\t}\n\n\treturn ret;\n};\n\nmodule.exports.isMatch = (input, pattern) => makeRe(pattern, true).test(input);\n"},"hash":"aa3fab1638ef3c13b4411d53c5e7269b"}