{"dependencies":[{"name":"../constants","loc":{"line":3,"column":26}},{"name":"../formatUtils","loc":{"line":4,"column":28}},{"name":"../recursorUtils","loc":{"line":5,"column":30}}],"generated":{"js":"'use strict'\n\nconst constants = require('../constants')\nconst formatUtils = require('../formatUtils')\nconst recursorUtils = require('../recursorUtils')\n\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nfunction describeComplex (index, value) {\n  return new ComplexItem(index, value)\n}\nexports.describeComplex = describeComplex\n\nfunction deserializeComplex (index, recursor) {\n  const value = recursor()\n  return new ComplexItem(index, value)\n}\nexports.deserializeComplex = deserializeComplex\n\nfunction describePrimitive (index, value) {\n  return new PrimitiveItem(index, value)\n}\nexports.describePrimitive = describePrimitive\n\nfunction deserializePrimitive (state) {\n  const index = state[0]\n  const value = state[1]\n  return new PrimitiveItem(index, value)\n}\nexports.deserializePrimitive = deserializePrimitive\n\nconst complexTag = Symbol('ComplexItem')\nexports.complexTag = complexTag\n\nconst primitiveTag = Symbol('PrimitiveItem')\nexports.primitiveTag = primitiveTag\n\nclass ComplexItem {\n  constructor (index, value) {\n    this.index = index\n    this.value = value\n  }\n\n  createRecursor () {\n    return recursorUtils.singleValue(this.value)\n  }\n\n  compare (expected) {\n    return expected.tag === complexTag && this.index === expected.index\n      ? this.value.compare(expected.value)\n      : UNEQUAL\n  }\n\n  formatShallow (theme, indent) {\n    const increaseValueIndent = theme.item.increaseValueIndent === true\n    return new formatUtils.SingleValueFormatter(theme, value => {\n      if (typeof theme.item.customFormat === 'function') {\n        return theme.item.customFormat(theme, indent, value)\n      }\n\n      return value.withLastPostfixed(theme.item.after)\n    }, increaseValueIndent)\n  }\n\n  prepareDiff (expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {\n    // Circular values cannot be compared. They must be treated as being unequal when diffing.\n    if (isCircular(this.value) || isCircular(expected.value)) return {compareResult: UNEQUAL}\n\n    // Try to line up this or remaining items with the expected items.\n    const lhsFork = recursorUtils.fork(lhsRecursor)\n    const rhsFork = recursorUtils.fork(rhsRecursor)\n    const initialExpected = expected\n\n    let expectedIsMissing = false\n    while (!expectedIsMissing && expected !== null && expected.isItem === true) {\n      if (expected.tag === complexTag) {\n        expectedIsMissing = compareComplexShape(this.value, expected.value) !== UNEQUAL\n      }\n\n      expected = rhsFork.shared()\n    }\n\n    let actualIsExtraneous = false\n    if (initialExpected.tag === complexTag) {\n      let actual = this\n      while (!actualIsExtraneous && actual !== null && actual.isItem === true) {\n        if (actual.tag === complexTag) {\n          actualIsExtraneous = compareComplexShape(actual.value, initialExpected.value) !== UNEQUAL\n        }\n\n        actual = lhsFork.shared()\n      }\n    } else if (initialExpected.tag === primitiveTag) {\n      let actual = this\n      while (!actualIsExtraneous && actual !== null && actual.isItem === true) {\n        if (actual.tag === primitiveTag) {\n          actualIsExtraneous = initialExpected.value.compare(actual.value) === DEEP_EQUAL\n        }\n\n        actual = lhsFork.shared()\n      }\n    }\n\n    if (actualIsExtraneous && !expectedIsMissing) {\n      return {\n        actualIsExtraneous: true,\n        lhsRecursor: lhsFork.recursor,\n        rhsRecursor: recursorUtils.map(\n          recursorUtils.unshift(rhsFork.recursor, initialExpected),\n          next => {\n            if (next.isItem !== true) return next\n\n            next.index++\n            return next\n          })\n      }\n    }\n\n    if (expectedIsMissing && !actualIsExtraneous) {\n      return {\n        expectedIsMissing: true,\n        lhsRecursor: recursorUtils.map(\n          recursorUtils.unshift(lhsFork.recursor, this),\n          next => {\n            if (next.isItem !== true) return next\n\n            next.index++\n            return next\n          }),\n        rhsRecursor: rhsFork.recursor\n      }\n    }\n\n    const mustRecurse = this.tag === complexTag && initialExpected.tag === complexTag &&\n      this.value.compare(initialExpected.value) !== UNEQUAL\n    return {\n      mustRecurse,\n      isUnequal: !mustRecurse,\n      lhsRecursor: lhsFork.recursor,\n      rhsRecursor: rhsFork.recursor\n    }\n  }\n\n  serialize () {\n    return this.index\n  }\n}\nObject.defineProperty(ComplexItem.prototype, 'isItem', { value: true })\nObject.defineProperty(ComplexItem.prototype, 'tag', { value: complexTag })\n\nclass PrimitiveItem {\n  constructor (index, value) {\n    this.index = index\n    this.value = value\n  }\n\n  compare (expected) {\n    return expected.tag === primitiveTag && this.index === expected.index\n      ? this.value.compare(expected.value)\n      : UNEQUAL\n  }\n\n  formatDeep (theme, indent) {\n    const increaseValueIndent = theme.item.increaseValueIndent === true\n    const valueIndent = increaseValueIndent ? indent.increase() : indent\n\n    // Since the value is formatted directly, modifiers are not applied. Apply\n    // modifiers to the item descriptor instead.\n    const formatted = this.value.formatDeep(theme, valueIndent)\n\n    if (typeof theme.item.customFormat === 'function') {\n      return theme.item.customFormat(theme, indent, formatted)\n    }\n\n    return formatted.withLastPostfixed(theme.item.after)\n  }\n\n  prepareDiff (expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {\n    const compareResult = this.compare(expected)\n    // Short-circuit when values are deeply equal.\n    if (compareResult === DEEP_EQUAL) return {compareResult}\n\n    // Short-circut when values can be diffed directly.\n    if (\n      expected.tag === primitiveTag &&\n      this.value.tag === expected.value.tag && typeof this.value.diffDeep === 'function'\n    ) {\n      return {compareResult}\n    }\n\n    // Try to line up this or remaining items with the expected items.\n    const rhsFork = recursorUtils.fork(rhsRecursor)\n    const initialExpected = expected\n\n    do {\n      if (expected === null || expected.isItem !== true) {\n        return {\n          actualIsExtraneous: true,\n          rhsRecursor: recursorUtils.map(\n            recursorUtils.unshift(rhsFork.recursor, initialExpected),\n            next => {\n              if (next.isItem !== true) return next\n\n              next.index++\n              return next\n            })\n        }\n      }\n\n      if (this.value.compare(expected.value) === DEEP_EQUAL) {\n        return {\n          expectedIsMissing: true,\n          lhsRecursor: recursorUtils.map(\n            recursorUtils.unshift(lhsRecursor, this),\n            next => {\n              if (next.isItem !== true) return next\n\n              next.index++\n              return next\n            }),\n          rhsRecursor: rhsFork.recursor\n        }\n      }\n\n      expected = rhsFork.shared()\n    } while (true)\n  }\n\n  diffDeep (expected, theme, indent) {\n    // Verify a diff can be returned.\n    if (this.tag !== expected.tag || typeof this.value.diffDeep !== 'function') return null\n\n    const increaseValueIndent = theme.property.increaseValueIndent === true\n    const valueIndent = increaseValueIndent ? indent.increase() : indent\n\n    // Since the value is diffed directly, modifiers are not applied. Apply\n    // modifiers to the item descriptor instead.\n    const diff = this.value.diffDeep(expected.value, theme, valueIndent)\n    if (diff === null) return null\n\n    if (typeof theme.item.customFormat === 'function') {\n      return theme.item.customFormat(theme, indent, diff)\n    }\n\n    return diff.withLastPostfixed(theme.item.after)\n  }\n\n  serialize () {\n    return [this.index, this.value]\n  }\n}\nObject.defineProperty(PrimitiveItem.prototype, 'isItem', { value: true })\nObject.defineProperty(PrimitiveItem.prototype, 'tag', { value: primitiveTag })\n"},"hash":"611683021084b9e2d34e3d13c1ce3119"}