{"dependencies":[{"name":"path","loc":{"line":5,"column":22}},{"name":"chalk","loc":{"line":6,"column":23}},{"name":"currently-unhandled","loc":{"line":19,"column":35}},{"name":"is-obj","loc":{"line":20,"column":22}},{"name":"./process-adapter","loc":{"line":22,"column":24}},{"name":"./globals","loc":{"line":23,"column":24}},{"name":"./serialize-error","loc":{"line":28,"column":31}},{"name":"process"}],"generated":{"js":"var process = require(\"process\");\n'use strict';\n\n// Check if the test is being run without AVA cli\n{\n\tconst path = require('path');\n\tconst chalk = require('chalk');\n\n\tconst isForked = typeof process.send === 'function';\n\tif (!isForked) {\n\t\tconst fp = path.relative('.', process.argv[1]);\n\n\t\tconsole.log();\n\t\tconsole.error('Test files must be run with the AVA CLI:\\n\\n    ' + chalk.grey.dim('$') + ' ' + chalk.cyan('ava ' + fp) + '\\n');\n\n\t\tprocess.exit(1); // eslint-disable-line unicorn/no-process-exit\n\t}\n}\n\nconst currentlyUnhandled = require('currently-unhandled')();\nconst isObj = require('is-obj');\n\nconst adapter = require('./process-adapter');\nconst globals = require('./globals');\n\nconst opts = adapter.opts;\nglobals.options = opts;\n\nconst serializeError = require('./serialize-error');\n\n(opts.require || []).forEach(x => require(x));\n\nadapter.installSourceMapSupport();\nadapter.installPrecompilerHook();\n\nconst testPath = opts.file;\n\nconst dependencies = new Set();\nadapter.installDependencyTracking(dependencies, testPath);\n\nconst touchedFiles = new Set();\n\n// Set when main.js is required (since test files should have `require('ava')`).\nlet runner = null;\nexports.setRunner = newRunner => {\n\trunner = newRunner;\n\trunner.on('dependency', file => {\n\t\tdependencies.add(file);\n\t});\n\trunner.on('touched', files => {\n\t\tfor (const file of files) {\n\t\t\ttouchedFiles.add(file);\n\t\t}\n\t});\n};\n\nrequire(testPath);\n\n// If AVA was not required, show an error\nif (!runner) {\n\tadapter.send('no-tests', {avaRequired: false});\n}\n\nfunction attributeLeakedError(err) {\n\tif (!runner) {\n\t\treturn false;\n\t}\n\n\treturn runner.attributeLeakedError(err);\n}\n\nconst attributedRejections = new Set();\nprocess.on('unhandledRejection', (reason, promise) => {\n\tif (attributeLeakedError(reason)) {\n\t\tattributedRejections.add(promise);\n\t}\n});\n\nprocess.on('uncaughtException', exception => {\n\tif (attributeLeakedError(exception)) {\n\t\treturn;\n\t}\n\n\tlet serialized;\n\ttry {\n\t\tserialized = serializeError(exception);\n\t} catch (ignore) { // eslint-disable-line unicorn/catch-error-name\n\t\t// Avoid using serializeError\n\t\tconst err = new Error('Failed to serialize uncaught exception');\n\t\tserialized = {\n\t\t\tavaAssertionError: false,\n\t\t\tname: err.name,\n\t\t\tmessage: err.message,\n\t\t\tstack: err.stack\n\t\t};\n\t}\n\n\t// Ensure the IPC channel is refereced. The uncaught exception will kick off\n\t// the teardown sequence, for which the messages must be received.\n\tadapter.ipcChannel.ref();\n\n\tadapter.send('uncaughtException', {exception: serialized});\n});\n\nlet tearingDown = false;\nprocess.on('ava-teardown', () => {\n\t// AVA-teardown can be sent more than once\n\tif (tearingDown) {\n\t\treturn;\n\t}\n\ttearingDown = true;\n\n\tlet rejections = currentlyUnhandled()\n\t\t.filter(rejection => !attributedRejections.has(rejection.promise));\n\n\tif (rejections.length > 0) {\n\t\trejections = rejections.map(rejection => {\n\t\t\tlet reason = rejection.reason;\n\t\t\tif (!isObj(reason) || typeof reason.message !== 'string') {\n\t\t\t\treason = {\n\t\t\t\t\tmessage: String(reason)\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn serializeError(reason);\n\t\t});\n\n\t\tadapter.send('unhandledRejections', {rejections});\n\t}\n\n\t// Include dependencies in the final teardown message. This ensures the full\n\t// set of dependencies is included no matter how the process exits, unless\n\t// it flat out crashes. Also include any files that AVA touched during the\n\t// test run. This allows the watcher to ignore modifications to those files.\n\tadapter.send('teardown', {\n\t\tdependencies: Array.from(dependencies),\n\t\ttouchedFiles: Array.from(touchedFiles)\n\t});\n});\n\nprocess.on('ava-exit', () => {\n\tprocess.exit(0); // eslint-disable-line xo/no-process-exit\n});\n"},"hash":"1c6b2a1968b236f6eda05f9266921f9e"}