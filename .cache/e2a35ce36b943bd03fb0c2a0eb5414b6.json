{"dependencies":[{"name":"concordance","loc":{"line":2,"column":28}},{"name":"core-assert","loc":{"line":3,"column":27}},{"name":"observable-to-promise","loc":{"line":4,"column":36}},{"name":"is-observable","loc":{"line":5,"column":29}},{"name":"is-promise","loc":{"line":6,"column":26}},{"name":"./concordance-options","loc":{"line":8,"column":39}},{"name":"./enhance-assert","loc":{"line":9,"column":30}},{"name":"./snapshot-manager","loc":{"line":10,"column":32}}],"generated":{"js":"\"use strict\";const e=require(\"concordance\"),s=require(\"core-assert\"),t=require(\"observable-to-promise\"),a=require(\"is-observable\"),r=require(\"is-promise\"),o=require(\"./concordance-options\").default,i=require(\"./concordance-options\").diff,n=require(\"./enhance-assert\"),c=require(\"./snapshot-manager\");function l(s,t,a){return a=Object.assign({},a,i),{label:\"Difference:\",formatted:e.diffDescriptors(s,t,a)}}function h(s,t){return{label:s,formatted:e.formatDescriptor(t,o)}}function u(s,t){return h(s,e.describe(t,o))}class p extends Error{constructor(e){super(e.message||\"\"),this.name=\"AssertionError\",this.assertion=e.assertion,this.fixedSource=e.fixedSource,this.improperUsage=e.improperUsage||!1,this.operator=e.operator,this.values=e.values||[],this.raw=e.raw,this.statements=[],e.stack&&(this.stack=e.stack)}}function w(){const e={};return Error.captureStackTrace(e,w),e.stack}function m(i){const m=i.pass,f=i.pending,g=i.fail,d=i.log,x=()=>{},v=e=>()=>{throw e},b={pass(){m(this)},fail(e){g(this,new p({assertion:\"fail\",message:e||\"Test failed via `t.fail()`\"}))},is(s,t,a){if(Object.is(s,t))m(this);else{const r=e.compare(s,t,o),i=r.actual||e.describe(s,o),n=r.expected||e.describe(t,o);r.pass?g(this,new p({assertion:\"is\",message:a,raw:{actual:s,expected:t},values:[h(\"Values are deeply equal to each other, but they are not the same:\",i)]})):g(this,new p({assertion:\"is\",message:a,raw:{actual:s,expected:t},values:[l(i,n)]}))}},not(e,s,t){Object.is(e,s)?g(this,new p({assertion:\"not\",message:t,raw:{actual:e,expected:s},values:[u(\"Value is the same as:\",e)]})):m(this)},log(e){d(this,e)},deepEqual(s,t,a){const r=e.compare(s,t,o);if(r.pass)m(this);else{const i=r.actual||e.describe(s,o),n=r.expected||e.describe(t,o);g(this,new p({assertion:\"deepEqual\",message:a,raw:{actual:s,expected:t},values:[l(i,n)]}))}},notDeepEqual(s,t,a){const r=e.compare(s,t,o);if(r.pass){const i=r.actual||e.describe(s,o);g(this,new p({assertion:\"notDeepEqual\",message:a,raw:{actual:s,expected:t},values:[h(\"Value is deeply equal:\",i)]}))}else m(this)},throws(e,o,i){let n,c;if(r(e))n=e;else if(a(e))n=t(e);else if(\"function\"!=typeof e)return void g(this,new p({assertion:\"throws\",improperUsage:!0,message:\"`t.throws()` must be called with a function, Promise, or Observable\",values:[u(\"Called with:\",e)]}));if(\"string\"==typeof o){const e=o;c=(s=>s.message===e)}else c=o;const l=(e,t)=>{let a,r=!1;try{return s.throws(()=>{try{e()}catch(e){throw a=e,r=!0,e}},c),a}catch(e){throw new p({assertion:\"throws\",message:i,stack:t,values:r?[u(\"Threw unexpected exception:\",a)]:null})}};if(n){const e=w(),s=n.then(e=>{throw new p({assertion:\"throws\",message:\"Expected promise to be rejected, but it was resolved instead\",values:[u(\"Resolved with:\",e)]})},s=>l(v(s),e));return f(this,s),s.catch(x)}try{const s=l(e);return m(this),s}catch(o){g(this,o)}},notThrows(e,o){let i;if(r(e))i=e;else if(a(e))i=t(e);else if(\"function\"!=typeof e)return void g(this,new p({assertion:\"notThrows\",improperUsage:!0,message:\"`t.notThrows()` must be called with a function, Promise, or Observable\",values:[u(\"Called with:\",e)]}));const n=(e,t)=>{try{s.doesNotThrow(e)}catch(e){throw new p({assertion:\"notThrows\",message:o,stack:t,values:[u(\"Threw:\",e.actual)]})}};if(i){const e=w(),s=i.then(x,s=>n(v(s),e));return f(this,s),s.catch(x)}try{n(e),m(this)}catch(e){g(this,e)}},ifError(e,s){e?g(this,new p({assertion:\"ifError\",message:s,values:[u(\"Error:\",e)]})):m(this)},snapshot(e,s,t){const a={};let r;\"string\"==typeof s?t=s:s&&(a.id=s.id),a.expected=e,a.message=t;try{r=this._test.compareWithSnapshot(a)}catch(e){if(!(e instanceof c.SnapshotError))throw e;const s={name:e.name,snapPath:e.snapPath};return e instanceof c.VersionMismatchError&&(s.snapVersion=e.snapVersion,s.expectedVersion=e.expectedVersion),void g(this,new p({assertion:\"snapshot\",message:t||\"Could not compare snapshot\",improperUsage:s}))}r.pass?m(this):r.actual?g(this,new p({assertion:\"snapshot\",message:t||\"Did not match snapshot\",values:[l(r.actual,r.expected,{invert:!0})]})):g(this,new p({assertion:\"snapshot\",message:t||\"No snapshot available, run with --update-snapshots\"}))}},y=n(m,g,{truthy(e,s){if(!e)throw new p({assertion:\"truthy\",message:s,operator:\"!!\",values:[u(\"Value is not truthy:\",e)]})},falsy(e,s){if(e)throw new p({assertion:\"falsy\",message:s,operator:\"!\",values:[u(\"Value is not falsy:\",e)]})},true(e,s){if(!0!==e)throw new p({assertion:\"true\",message:s,values:[u(\"Value is not `true`:\",e)]})},false(e,s){if(!1!==e)throw new p({assertion:\"false\",message:s,values:[u(\"Value is not `false`:\",e)]})},regex(e,s,t){if(\"string\"!=typeof e)throw new p({assertion:\"regex\",improperUsage:!0,message:\"`t.regex()` must be called with a string\",values:[u(\"Called with:\",e)]});if(!(s instanceof RegExp))throw new p({assertion:\"regex\",improperUsage:!0,message:\"`t.regex()` must be called with a regular expression\",values:[u(\"Called with:\",s)]});if(!s.test(e))throw new p({assertion:\"regex\",message:t,values:[u(\"Value must match expression:\",e),u(\"Regular expression:\",s)]})},notRegex(e,s,t){if(\"string\"!=typeof e)throw new p({assertion:\"notRegex\",improperUsage:!0,message:\"`t.notRegex()` must be called with a string\",values:[u(\"Called with:\",e)]});if(!(s instanceof RegExp))throw new p({assertion:\"notRegex\",improperUsage:!0,message:\"`t.notRegex()` must be called with a regular expression\",values:[u(\"Called with:\",s)]});if(s.test(e))throw new p({assertion:\"notRegex\",message:t,values:[u(\"Value must not match expression:\",e),u(\"Regular expression:\",s)]})}});return Object.assign(b,y)}exports.AssertionError=p,exports.wrapAssertions=m;"},"hash":"a975ddd55b5e4f9ce32cb35739becc32"}