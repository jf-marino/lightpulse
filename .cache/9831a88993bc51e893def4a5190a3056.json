{"dependencies":[{"name":"semver","loc":{"line":3,"column":23}},{"name":"../package.json","loc":{"line":5,"column":20}},{"name":"./constants","loc":{"line":6,"column":26}},{"name":"./complexValues/object","loc":{"line":7,"column":23}},{"name":"./lineBuilder","loc":{"line":8,"column":28}},{"name":"./formatUtils","loc":{"line":9,"column":28}},{"name":"./metaDescriptors/item","loc":{"line":10,"column":31}},{"name":"./metaDescriptors/property","loc":{"line":11,"column":35}},{"name":"./primitiveValues/string","loc":{"line":12,"column":33}},{"name":"./recursorUtils","loc":{"line":13,"column":30}},{"name":"./themeUtils","loc":{"line":14,"column":27}}],"generated":{"js":"'use strict'\n\nconst semver = require('semver')\n\nconst pkg = require('../package.json')\nconst constants = require('./constants')\nconst object = require('./complexValues/object')\nconst lineBuilder = require('./lineBuilder')\nconst formatUtils = require('./formatUtils')\nconst itemDescriptor = require('./metaDescriptors/item')\nconst propertyDescriptor = require('./metaDescriptors/property')\nconst stringDescriptor = require('./primitiveValues/string')\nconst recursorUtils = require('./recursorUtils')\nconst themeUtils = require('./themeUtils')\n\nconst API_VERSION = 1\nconst CONCORDANCE_VERSION = pkg.version\n\nconst descriptorRegistry = new Map()\nconst registry = new Map()\n\nclass PluginError extends Error {\n  constructor (message, plugin) {\n    super(message)\n    this.name = 'PluginError'\n    this.plugin = plugin\n  }\n}\n\nclass PluginTypeError extends TypeError {\n  constructor (message, plugin) {\n    super(message)\n    this.name = 'PluginTypeError'\n    this.plugin = plugin\n  }\n}\n\nclass UnsupportedApiError extends PluginError {\n  constructor (plugin) {\n    super('Plugin requires an unsupported API version', plugin)\n    this.name = 'UnsupportedApiError'\n  }\n}\n\nclass UnsupportedError extends PluginError {\n  constructor (plugin) {\n    super('Plugin does not support this version of Concordance', plugin)\n    this.name = 'UnsupportedError'\n  }\n}\n\nclass DuplicateDescriptorTagError extends PluginError {\n  constructor (tag, plugin) {\n    super(`Could not add descriptor: tag ${String(tag)} has already been registered`, plugin)\n    this.name = 'DuplicateDescriptorTagError'\n    this.tag = tag\n  }\n}\n\nclass DuplicateDescriptorIdError extends PluginError {\n  constructor (id, plugin) {\n    const printed = typeof id === 'number'\n      ? `0x${id.toString(16).toUpperCase()}`\n      : String(id)\n    super(`Could not add descriptor: id ${printed} has already been registered`, plugin)\n    this.name = 'DuplicateDescriptorIdError'\n    this.id = id\n  }\n}\n\nfunction verify (plugin) {\n  if (typeof plugin.name !== 'string' || !plugin.name) {\n    throw new PluginTypeError('Plugin must have a `name`', plugin)\n  }\n\n  if (plugin.apiVersion !== API_VERSION) {\n    throw new UnsupportedApiError(plugin)\n  }\n\n  if ('minimalConcordanceVersion' in plugin) {\n    if (!semver.valid(plugin.minimalConcordanceVersion)) {\n      throw new PluginTypeError('If specified, `minimalConcordanceVersion` must be a valid SemVer version', plugin)\n    }\n\n    const range = `>=${plugin.minimalConcordanceVersion}`\n    if (!semver.satisfies(CONCORDANCE_VERSION, range)) {\n      throw new UnsupportedError(plugin)\n    }\n  }\n}\n\n// Selectively expose descriptor tags.\nconst publicDescriptorTags = Object.freeze({\n  complexItem: itemDescriptor.complexTag,\n  primitiveItem: itemDescriptor.primitiveTag,\n  primitiveProperty: propertyDescriptor.primitiveTag,\n  string: stringDescriptor.tag\n})\n\n// Don't expose `setDefaultGutter()`.\nconst publicLineBuilder = Object.freeze({\n  buffer: lineBuilder.buffer,\n  first: lineBuilder.first,\n  last: lineBuilder.last,\n  line: lineBuilder.line,\n  single: lineBuilder.single,\n  actual: Object.freeze({\n    buffer: lineBuilder.actual.buffer,\n    first: lineBuilder.actual.first,\n    last: lineBuilder.actual.last,\n    line: lineBuilder.actual.line,\n    single: lineBuilder.actual.single\n  }),\n  expected: Object.freeze({\n    buffer: lineBuilder.expected.buffer,\n    first: lineBuilder.expected.first,\n    last: lineBuilder.expected.last,\n    line: lineBuilder.expected.line,\n    single: lineBuilder.expected.single\n  })\n})\n\nfunction modifyTheme (descriptor, modifier) {\n  themeUtils.addModifier(descriptor, modifier)\n  return descriptor\n}\n\nfunction add (plugin) {\n  verify(plugin)\n\n  const name = plugin.name\n  if (registry.has(name)) return registry.get(name)\n\n  const id2deserialize = new Map()\n  const tag2id = new Map()\n  const addDescriptor = (id, tag, deserialize) => {\n    if (id2deserialize.has(id)) throw new DuplicateDescriptorIdError(id, plugin)\n    if (descriptorRegistry.has(tag) || tag2id.has(tag)) throw new DuplicateDescriptorTagError(tag, plugin)\n\n    id2deserialize.set(id, deserialize)\n    tag2id.set(tag, id)\n  }\n\n  const tryDescribeValue = plugin.register({\n    // Concordance makes assumptions about when AMBIGUOUS occurs. Do not expose\n    // it to plugins.\n    UNEQUAL: constants.UNEQUAL,\n    SHALLOW_EQUAL: constants.SHALLOW_EQUAL,\n    DEEP_EQUAL: constants.DEEP_EQUAL,\n\n    ObjectValue: object.ObjectValue,\n    DescribedMixin: object.DescribedMixin,\n    DeserializedMixin: object.DeserializedMixin,\n\n    addDescriptor,\n    applyThemeModifiers: themeUtils.applyModifiers,\n    descriptorTags: publicDescriptorTags,\n    lineBuilder: publicLineBuilder,\n    mapRecursor: recursorUtils.map,\n    modifyTheme,\n    wrapFromTheme: formatUtils.wrap\n  })\n\n  const registered = {\n    id2deserialize,\n    serializerVersion: plugin.serializerVersion,\n    name,\n    tag2id,\n    theme: plugin.theme || {},\n    tryDescribeValue\n  }\n\n  registry.set(name, registered)\n  for (const tag of tag2id.keys()) {\n    descriptorRegistry.set(tag, registered)\n  }\n\n  return registered\n}\nexports.add = add\n\nfunction getDeserializers (plugins) {\n  return plugins.map(plugin => {\n    const registered = add(plugin)\n    return {\n      id2deserialize: registered.id2deserialize,\n      name: registered.name,\n      serializerVersion: registered.serializerVersion\n    }\n  })\n}\nexports.getDeserializers = getDeserializers\n\nfunction getThemes (plugins) {\n  return plugins.map(plugin => {\n    const registered = add(plugin)\n    return {\n      name: registered.name,\n      theme: registered.theme\n    }\n  })\n}\nexports.getThemes = getThemes\n\nfunction getTryDescribeValues (plugins) {\n  return plugins.map(plugin => add(plugin).tryDescribeValue)\n}\nexports.getTryDescribeValues = getTryDescribeValues\n\nfunction resolveDescriptorRef (tag) {\n  if (!descriptorRegistry.has(tag)) return null\n\n  const registered = descriptorRegistry.get(tag)\n  return {\n    id: registered.tag2id.get(tag),\n    name: registered.name,\n    serialization: {\n      serializerVersion: registered.serializerVersion\n    }\n  }\n}\nexports.resolveDescriptorRef = resolveDescriptorRef\n"},"hash":"300cb9f02da28d6e21ba2a53515e730c"}