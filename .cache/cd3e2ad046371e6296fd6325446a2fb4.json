{"dependencies":[{"name":"../constants","loc":{"line":3,"column":26}},{"name":"../formatUtils","loc":{"line":4,"column":28}},{"name":"../lineBuilder","loc":{"line":5,"column":28}},{"name":"./object","loc":{"line":6,"column":23}}],"generated":{"js":"'use strict'\n\nconst constants = require('../constants')\nconst formatUtils = require('../formatUtils')\nconst lineBuilder = require('../lineBuilder')\nconst object = require('./object')\n\nconst UNEQUAL = constants.UNEQUAL\n\nfunction describe (props) {\n  const regexp = props.value\n  return new DescribedRegexpValue(Object.assign({\n    flags: getSortedFlags(regexp),\n    source: regexp.source\n  }, props))\n}\nexports.describe = describe\n\nfunction deserialize (state, recursor) {\n  return new DeserializedRegexpValue(state, recursor)\n}\nexports.deserialize = deserialize\n\nconst tag = Symbol('RegexpValue')\nexports.tag = tag\n\nfunction getSortedFlags (regexp) {\n  const flags = regexp.flags || String(regexp).slice(regexp.source.length + 2)\n  return flags.split('').sort().join('')\n}\n\nclass RegexpValue extends object.ObjectValue {\n  constructor (props) {\n    super(props)\n    this.flags = props.flags\n    this.source = props.source\n  }\n\n  compare (expected) {\n    return this.tag === expected.tag && this.flags === expected.flags && this.source === expected.source\n      ? super.compare(expected)\n      : UNEQUAL\n  }\n\n  formatShallow (theme, indent) {\n    const ctor = this.ctor || this.stringTag\n    const regexp = formatUtils.wrap(theme.regexp.source, this.source) + formatUtils.wrap(theme.regexp.flags, this.flags)\n\n    return super.formatShallow(theme, indent).customize({\n      finalize: innerLines => {\n        if (ctor === 'RegExp' && innerLines.isEmpty) return lineBuilder.single(regexp)\n\n        const innerIndentation = indent.increase()\n        const header = lineBuilder.first(formatUtils.formatCtorAndStringTag(theme, this) + ' ' + theme.object.openBracket)\n          .concat(lineBuilder.line(innerIndentation + regexp))\n\n        if (!innerLines.isEmpty) {\n          header.append(lineBuilder.line(innerIndentation + theme.regexp.separator))\n          header.append(innerLines.withFirstPrefixed(innerIndentation).stripFlags())\n        }\n\n        return header.append(lineBuilder.last(indent + theme.object.closeBracket))\n      },\n\n      maxDepth: () => {\n        return lineBuilder.single(\n          formatUtils.formatCtorAndStringTag(theme, this) + ' ' +\n          theme.object.openBracket + ' ' +\n          regexp + ' ' +\n          theme.maxDepth + ' ' +\n          theme.object.closeBracket)\n      }\n    })\n  }\n\n  serialize () {\n    return [this.flags, this.source, super.serialize()]\n  }\n}\nObject.defineProperty(RegexpValue.prototype, 'tag', { value: tag })\n\nconst DescribedRegexpValue = object.DescribedMixin(RegexpValue)\n\nclass DeserializedRegexpValue extends object.DeserializedMixin(RegexpValue) {\n  constructor (state, recursor) {\n    super(state[2], recursor)\n    this.flags = state[0]\n    this.source = state[1]\n  }\n}\n"},"hash":"646a1d88910d1636e8b55cd1fb46ada0"}