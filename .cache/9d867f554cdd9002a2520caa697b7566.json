{"dependencies":[{"name":"lodash/map","loc":{"line":3,"column":19}},{"name":"babel-types","loc":{"line":7,"column":26}}],"generated":{"js":"\"use strict\";\n\nvar _map = require(\"lodash/map\");\n\nvar _map2 = _interopRequireDefault(_map);\n\nvar _babelTypes = require(\"babel-types\");\n\nvar t = _interopRequireWildcard(_babelTypes);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction crawl(node) {\n  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (t.isMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\nexports.nodes = {\n  AssignmentExpression: function AssignmentExpression(node) {\n    var state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n  SwitchCase: function SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node\n    };\n  },\n  LogicalExpression: function LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n  Literal: function Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n  CallExpression: function CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n  VariableDeclaration: function VariableDeclaration(node) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n\n      var enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled) {\n        var state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n  IfStatement: function IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n};\n\nexports.nodes.ObjectProperty = exports.nodes.ObjectTypeProperty = exports.nodes.ObjectMethod = exports.nodes.SpreadProperty = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\nexports.list = {\n  VariableDeclaration: function VariableDeclaration(node) {\n    return (0, _map2.default)(node.declarations, \"init\");\n  },\n  ArrayExpression: function ArrayExpression(node) {\n    return node.elements;\n  },\n  ObjectExpression: function ObjectExpression(node) {\n    return node.properties;\n  }\n};\n\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  var type = _ref[0],\n      amounts = _ref[1];\n\n  if (typeof amounts === \"boolean\") {\n    amounts = { after: amounts, before: amounts };\n  }\n  [type].concat(t.FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    exports.nodes[type] = function () {\n      return amounts;\n    };\n  });\n});"},"hash":"9cc305b457ebfefcd11b032394dd59eb"}