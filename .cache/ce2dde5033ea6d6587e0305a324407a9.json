{"dependencies":[{"name":"./constants","loc":{"line":3,"column":26}},{"name":"./describe","loc":{"line":4,"column":25}},{"name":"./lineBuilder","loc":{"line":5,"column":28}},{"name":"./recursorUtils","loc":{"line":6,"column":30}},{"name":"./shouldCompareDeep","loc":{"line":7,"column":34}},{"name":"./symbolProperties","loc":{"line":8,"column":33}},{"name":"./themeUtils","loc":{"line":9,"column":27}},{"name":"./Circular","loc":{"line":10,"column":25}},{"name":"./Indenter","loc":{"line":11,"column":25}}],"generated":{"js":"'use strict'\n\nconst constants = require('./constants')\nconst describe = require('./describe')\nconst lineBuilder = require('./lineBuilder')\nconst recursorUtils = require('./recursorUtils')\nconst shouldCompareDeep = require('./shouldCompareDeep')\nconst symbolProperties = require('./symbolProperties')\nconst themeUtils = require('./themeUtils')\nconst Circular = require('./Circular')\nconst Indenter = require('./Indenter')\n\nconst AMBIGUOUS = constants.AMBIGUOUS\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\nconst SHALLOW_EQUAL = constants.SHALLOW_EQUAL\nconst NOOP = Symbol('NOOP')\n\nconst alwaysFormat = () => true\n\nfunction compareComplexShape (lhs, rhs) {\n  let result = lhs.compare(rhs)\n  if (result === DEEP_EQUAL) return DEEP_EQUAL\n  if (result === UNEQUAL || !shouldCompareDeep(result, lhs, rhs)) return UNEQUAL\n\n  let collectedSymbolProperties = false\n  let lhsRecursor = lhs.createRecursor()\n  let rhsRecursor = rhs.createRecursor()\n\n  do {\n    lhs = lhsRecursor()\n    rhs = rhsRecursor()\n\n    if (lhs === null && rhs === null) return SHALLOW_EQUAL\n    if (lhs === null || rhs === null) return UNEQUAL\n\n    result = lhs.compare(rhs)\n    if (result === UNEQUAL) return UNEQUAL\n    if (\n      result === AMBIGUOUS &&\n      lhs.isProperty === true && !collectedSymbolProperties &&\n      shouldCompareDeep(result, lhs, rhs)\n    ) {\n      collectedSymbolProperties = true\n      const lhsCollector = new symbolProperties.Collector(lhs, lhsRecursor)\n      const rhsCollector = new symbolProperties.Collector(rhs, rhsRecursor)\n\n      lhsRecursor = recursorUtils.sequence(\n        lhsCollector.createRecursor(),\n        recursorUtils.unshift(lhsRecursor, lhsCollector.collectAll()))\n      rhsRecursor = recursorUtils.sequence(\n        rhsCollector.createRecursor(),\n        recursorUtils.unshift(rhsRecursor, rhsCollector.collectAll()))\n    }\n  } while (true)\n}\n\nfunction diffDescriptors (lhs, rhs, options) {\n  const theme = themeUtils.normalize(options)\n  const invert = options ? options.invert === true : false\n\n  const lhsCircular = new Circular()\n  const rhsCircular = new Circular()\n  const maxDepth = (options && options.maxDepth) || 0\n\n  let indent = new Indenter(0, '  ')\n\n  const lhsStack = []\n  const rhsStack = []\n  let topIndex = -1\n\n  const buffer = lineBuilder.buffer()\n  const diffStack = []\n  let diffIndex = -1\n\n  const isCircular = descriptor => lhsCircular.has(descriptor) || rhsCircular.has(descriptor)\n\n  const format = (builder, subject, circular) => {\n    if (diffIndex >= 0 && !diffStack[diffIndex].shouldFormat(subject)) return\n\n    if (circular.has(subject)) {\n      diffStack[diffIndex].formatter.append(builder.single(theme.circular))\n      return\n    }\n\n    const formatStack = []\n    let formatIndex = -1\n\n    do {\n      if (circular.has(subject)) {\n        formatStack[formatIndex].formatter.append(builder.single(theme.circular), subject)\n      } else {\n        let didFormat = false\n        if (typeof subject.formatDeep === 'function') {\n          let formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), indent)\n          if (formatted !== null) {\n            didFormat = true\n\n            if (formatIndex === -1) {\n              formatted = builder.setDefaultGutter(formatted)\n              if (diffIndex === -1) {\n                buffer.append(formatted)\n              } else {\n                diffStack[diffIndex].formatter.append(formatted, subject)\n              }\n            } else {\n              formatStack[formatIndex].formatter.append(formatted, subject)\n            }\n          }\n        }\n\n        if (!didFormat && typeof subject.formatShallow === 'function') {\n          const formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent)\n          const recursor = subject.createRecursor()\n\n          if (formatter.increaseIndent && maxDepth > 0 && indent.level === maxDepth) {\n            const isEmpty = recursor() === null\n            let formatted = !isEmpty && typeof formatter.maxDepth === 'function'\n              ? formatter.maxDepth()\n              : formatter.finalize()\n\n            if (formatIndex === -1) {\n              formatted = builder.setDefaultGutter(formatted)\n              diffStack[diffIndex].formatter.append(formatted, subject)\n            } else {\n              formatStack[formatIndex].formatter.append(formatted, subject)\n            }\n          } else {\n            formatStack.push({\n              formatter,\n              recursor,\n              decreaseIndent: formatter.increaseIndent,\n              shouldFormat: formatter.shouldFormat || alwaysFormat,\n              subject\n            })\n            formatIndex++\n\n            if (formatter.increaseIndent) indent = indent.increase()\n            circular.add(subject)\n          }\n        }\n      }\n\n      while (formatIndex >= 0) {\n        do {\n          subject = formatStack[formatIndex].recursor()\n        } while (subject && !formatStack[formatIndex].shouldFormat(subject))\n\n        if (subject) {\n          break\n        }\n\n        const record = formatStack.pop()\n        formatIndex--\n        if (record.decreaseIndent) indent = indent.decrease()\n        circular.delete(record.subject)\n\n        let formatted = record.formatter.finalize()\n        if (formatIndex === -1) {\n          formatted = builder.setDefaultGutter(formatted)\n          if (diffIndex === -1) {\n            buffer.append(formatted)\n          } else {\n            diffStack[diffIndex].formatter.append(formatted, record.subject)\n          }\n        } else {\n          formatStack[formatIndex].formatter.append(formatted, record.subject)\n        }\n      }\n    } while (formatIndex >= 0)\n  }\n\n  do {\n    let compareResult = NOOP\n    if (lhsCircular.has(lhs)) {\n      compareResult = lhsCircular.get(lhs) === rhsCircular.get(rhs)\n        ? DEEP_EQUAL\n        : UNEQUAL\n    } else if (rhsCircular.has(rhs)) {\n      compareResult = UNEQUAL\n    }\n\n    let firstPassSymbolProperty = false\n    if (lhs.isProperty === true) {\n      compareResult = lhs.compare(rhs)\n      if (compareResult === AMBIGUOUS) {\n        const parent = lhsStack[topIndex].subject\n        firstPassSymbolProperty = parent.isSymbolPropertiesCollector !== true && parent.isSymbolPropertiesComparable !== true\n      }\n    }\n\n    let didFormat = false\n    let mustRecurse = false\n    if (compareResult !== DEEP_EQUAL && !firstPassSymbolProperty && typeof lhs.prepareDiff === 'function') {\n      const lhsRecursor = topIndex === -1 ? null : lhsStack[topIndex].recursor\n      const rhsRecursor = topIndex === -1 ? null : rhsStack[topIndex].recursor\n\n      const instructions = lhs.prepareDiff(\n        rhs,\n        lhsRecursor,\n        rhsRecursor,\n        compareComplexShape,\n        isCircular)\n\n      if (instructions !== null) {\n        if (topIndex >= 0) {\n          if (typeof instructions.lhsRecursor === 'function') {\n            lhsStack[topIndex].recursor = instructions.lhsRecursor\n          }\n          if (typeof instructions.rhsRecursor === 'function') {\n            rhsStack[topIndex].recursor = instructions.rhsRecursor\n          }\n        }\n\n        if (instructions.compareResult) {\n          compareResult = instructions.compareResult\n        }\n        if (instructions.mustRecurse === true) {\n          mustRecurse = true\n        } else {\n          if (instructions.actualIsExtraneous === true) {\n            format(lineBuilder.actual, lhs, lhsCircular)\n            didFormat = true\n          } else if (instructions.multipleAreExtraneous === true) {\n            for (const extraneous of instructions.descriptors) {\n              format(lineBuilder.actual, extraneous, lhsCircular)\n            }\n            didFormat = true\n          } else if (instructions.expectedIsMissing === true) {\n            format(lineBuilder.expected, rhs, rhsCircular)\n            didFormat = true\n          } else if (instructions.multipleAreMissing === true) {\n            for (const missing of instructions.descriptors) {\n              format(lineBuilder.expected, missing, rhsCircular)\n            }\n            didFormat = true\n          } else if (instructions.isUnequal === true) {\n            format(lineBuilder.actual, lhs, lhsCircular)\n            format(lineBuilder.expected, rhs, rhsCircular)\n            didFormat = true\n          } else if (!instructions.compareResult) {\n            // TODO: Throw a useful, custom error\n            throw new Error('Illegal result of prepareDiff()')\n          }\n        }\n      }\n    }\n\n    if (!didFormat) {\n      if (compareResult === NOOP) {\n        compareResult = lhs.compare(rhs)\n      }\n\n      if (!mustRecurse) {\n        mustRecurse = shouldCompareDeep(compareResult, lhs, rhs)\n      }\n\n      if (compareResult === DEEP_EQUAL) {\n        format(lineBuilder, lhs, lhsCircular)\n      } else if (mustRecurse) {\n        if (compareResult === AMBIGUOUS && lhs.isProperty === true) {\n          // Replace both sides by a pseudo-descriptor which collects symbol\n          // properties instead.\n          lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor)\n          rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor)\n          // Replace the current recursors so they can continue correctly after\n          // the collectors have been \"compared\". This is necessary since the\n          // collectors eat the first value after the last symbol property.\n          lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll())\n          rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll())\n        }\n\n        if (typeof lhs.diffShallow === 'function') {\n          const formatter = lhs.diffShallow(rhs, themeUtils.applyModifiers(lhs, theme), indent)\n          diffStack.push({\n            formatter,\n            origin: lhs,\n            decreaseIndent: formatter.increaseIndent,\n            exceedsMaxDepth: formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,\n            shouldFormat: formatter.shouldFormat || alwaysFormat\n          })\n          diffIndex++\n\n          if (formatter.increaseIndent) indent = indent.increase()\n        } else if (typeof lhs.formatShallow === 'function') {\n          const formatter = lhs.formatShallow(themeUtils.applyModifiers(lhs, theme), indent)\n          diffStack.push({\n            formatter,\n            decreaseIndent: formatter.increaseIndent,\n            exceedsMaxDepth: formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,\n            shouldFormat: formatter.shouldFormat || alwaysFormat,\n            subject: lhs\n          })\n          diffIndex++\n\n          if (formatter.increaseIndent) indent = indent.increase()\n        }\n\n        lhsCircular.add(lhs)\n        rhsCircular.add(rhs)\n\n        lhsStack.push({ diffIndex, subject: lhs, recursor: lhs.createRecursor() })\n        rhsStack.push({ diffIndex, subject: rhs, recursor: rhs.createRecursor() })\n        topIndex++\n      } else {\n        const diffed = typeof lhs.diffDeep === 'function'\n          ? lhs.diffDeep(rhs, themeUtils.applyModifiers(lhs, theme), indent)\n          : null\n\n        if (diffed === null) {\n          format(lineBuilder.actual, lhs, lhsCircular)\n          format(lineBuilder.expected, rhs, rhsCircular)\n        } else {\n          if (diffIndex === -1) {\n            buffer.append(diffed)\n          } else {\n            diffStack[diffIndex].formatter.append(diffed, lhs)\n          }\n        }\n      }\n    }\n\n    while (topIndex >= 0) {\n      lhs = lhsStack[topIndex].recursor()\n      rhs = rhsStack[topIndex].recursor()\n\n      if (lhs !== null && rhs !== null) {\n        break\n      }\n\n      if (lhs === null && rhs === null) {\n        const lhsRecord = lhsStack.pop()\n        const rhsRecord = rhsStack.pop()\n        lhsCircular.delete(lhsRecord.subject)\n        rhsCircular.delete(rhsRecord.subject)\n        topIndex--\n\n        if (lhsRecord.diffIndex === diffIndex) {\n          const record = diffStack.pop()\n          diffIndex--\n          if (record.decreaseIndent) indent = indent.decrease()\n\n          let formatted = record.formatter.finalize()\n          if (record.exceedsMaxDepth && !formatted.hasGutter) {\n            // The record exceeds the max depth, but contains no actual diff.\n            // Discard the potentially deep formatting and format just the\n            // original subject.\n            const subject = lhsRecord.subject\n            const formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent)\n            const isEmpty = subject.createRecursor()() === null\n            formatted = !isEmpty && typeof formatter.maxDepth === 'function'\n              ? formatter.maxDepth()\n              : formatter.finalize()\n          }\n\n          if (diffIndex === -1) {\n            buffer.append(formatted)\n          } else {\n            diffStack[diffIndex].formatter.append(formatted, record.subject)\n          }\n        }\n      } else {\n        let builder, circular, stack, subject\n        if (lhs === null) {\n          builder = lineBuilder.expected\n          circular = rhsCircular\n          stack = rhsStack\n          subject = rhs\n        } else {\n          builder = lineBuilder.actual\n          circular = lhsCircular\n          stack = lhsStack\n          subject = lhs\n        }\n\n        do {\n          format(builder, subject, circular)\n          subject = stack[topIndex].recursor()\n        } while (subject !== null)\n      }\n    }\n  } while (topIndex >= 0)\n\n  return buffer.toString({diff: true, invert, theme})\n}\nexports.diffDescriptors = diffDescriptors\n\nfunction diff (actual, expected, options) {\n  return diffDescriptors(describe(actual, options), describe(expected, options), options)\n}\nexports.diff = diff\n"},"hash":"2290f43bbbfa2ac7e5ee82ab54a46d1e"}