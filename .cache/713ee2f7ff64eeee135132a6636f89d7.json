{"dependencies":[{"name":"../constants","loc":{"line":3,"column":26}},{"name":"../lineBuilder","loc":{"line":4,"column":28}},{"name":"../recursorUtils","loc":{"line":5,"column":30}},{"name":"../themeUtils","loc":{"line":6,"column":27}}],"generated":{"js":"'use strict'\n\nconst constants = require('../constants')\nconst lineBuilder = require('../lineBuilder')\nconst recursorUtils = require('../recursorUtils')\nconst themeUtils = require('../themeUtils')\n\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst UNEQUAL = constants.UNEQUAL\nconst SHALLOW_EQUAL = constants.SHALLOW_EQUAL\n\nfunction describe (keyDescriptor, valueDescriptor) {\n  const keyIsPrimitive = keyDescriptor.isPrimitive === true\n  const valueIsPrimitive = valueDescriptor.isPrimitive === true\n\n  return new MapEntry(keyDescriptor, valueDescriptor, keyIsPrimitive, valueIsPrimitive)\n}\nexports.describe = describe\n\nfunction deserialize (state, recursor) {\n  const keyIsPrimitive = state[0]\n  const valueIsPrimitive = state[1]\n  const keyDescriptor = recursor()\n  const valueDescriptor = recursor()\n\n  return new MapEntry(keyDescriptor, valueDescriptor, keyIsPrimitive, valueIsPrimitive)\n}\nexports.deserialize = deserialize\n\nconst tag = Symbol('MapEntry')\nexports.tag = tag\n\nfunction mergeWithKey (theme, key, values) {\n  const lines = lineBuilder.buffer()\n  const keyRemainder = lineBuilder.buffer()\n  for (const line of key) {\n    if (!line.isLast && !line.hasGutter) {\n      lines.append(line)\n    } else {\n      keyRemainder.append(line)\n    }\n  }\n  for (const value of values) {\n    lines.append(keyRemainder.mergeWithInfix(theme.mapEntry.separator, value).withLastPostfixed(theme.mapEntry.after))\n  }\n  return lines\n}\n\nclass MapEntry {\n  constructor (key, value, keyIsPrimitive, valueIsPrimitive) {\n    this.key = key\n    this.value = value\n    this.keyIsPrimitive = keyIsPrimitive\n    this.valueIsPrimitive = valueIsPrimitive\n  }\n\n  createRecursor () {\n    let emitKey = true\n    let emitValue = true\n\n    return () => {\n      if (emitKey) {\n        emitKey = false\n        return this.key\n      }\n\n      if (emitValue) {\n        emitValue = false\n        return this.value\n      }\n\n      return null\n    }\n  }\n\n  compare (expected) {\n    if (this.tag !== expected.tag) return UNEQUAL\n    if (this.keyIsPrimitive !== expected.keyIsPrimitive) return UNEQUAL\n    if (this.valueIsPrimitive !== expected.valueIsPrimitive) return UNEQUAL\n\n    if (!this.keyIsPrimitive) return SHALLOW_EQUAL\n\n    const keyResult = this.key.compare(expected.key)\n    if (keyResult !== DEEP_EQUAL) return keyResult\n\n    if (!this.valueIsPrimitive) return SHALLOW_EQUAL\n    return this.value.compare(expected.value)\n  }\n\n  formatDeep (theme, indent) {\n    // Verify the map entry can be formatted directly.\n    if (!this.keyIsPrimitive || typeof this.value.formatDeep !== 'function') return null\n\n    // Since formatShallow() would result in theme modifiers being applied\n    // before the key and value are formatted, do the same here.\n    const value = this.value.formatDeep(themeUtils.applyModifiersToOriginal(this.value, theme), indent)\n    if (value === null) return null\n\n    const key = this.key.formatDeep(themeUtils.applyModifiersToOriginal(this.key, theme), indent)\n    return mergeWithKey(theme, key, [value])\n  }\n\n  formatShallow (theme, indent) {\n    let key = null\n    const values = []\n    return {\n      append: (formatted, origin) => {\n        if (this.key === origin) {\n          key = formatted\n        } else {\n          values.push(formatted)\n        }\n      },\n      finalize () {\n        return mergeWithKey(theme, key, values)\n      }\n    }\n  }\n\n  diffDeep (expected, theme, indent) {\n    // Verify a diff can be returned.\n    if (this.tag !== expected.tag || typeof this.value.diffDeep !== 'function') return null\n    // Only use this logic to format value diffs when the keys are primitive and equal.\n    if (!this.keyIsPrimitive || !expected.keyIsPrimitive || this.key.compare(expected.key) !== DEEP_EQUAL) {\n      return null\n    }\n\n    // Since formatShallow() would result in theme modifiers being applied\n    // before the key and value are formatted, do the same here.\n    const diff = this.value.diffDeep(expected.value, themeUtils.applyModifiersToOriginal(this.value, theme), indent)\n    if (diff === null) return null\n\n    const key = this.key.formatDeep(themeUtils.applyModifiersToOriginal(this.key, theme), indent, '')\n    return mergeWithKey(theme, key, [diff])\n  }\n\n  prepareDiff (expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {\n    // Circular values cannot be compared. They must be treated as being unequal when diffing.\n    if (isCircular(this.value) || isCircular(expected.value)) return {compareResult: UNEQUAL}\n\n    const compareResult = this.compare(expected)\n    const keysAreEqual = this.tag === expected.tag && this.key.compare(expected.key) === DEEP_EQUAL\n    // Short-circuit when keys and/or values are deeply equal.\n    if (compareResult === DEEP_EQUAL || keysAreEqual) return {compareResult}\n\n    // Try to line up this or remaining map entries with the expected entries.\n    const lhsFork = recursorUtils.fork(lhsRecursor)\n    const rhsFork = recursorUtils.fork(rhsRecursor)\n    const initialExpected = expected\n\n    let expectedIsMissing = false\n    while (!expectedIsMissing && expected !== null && this.tag === expected.tag) {\n      if (expected.keyIsPrimitive) {\n        expectedIsMissing = this.key.compare(expected.key) !== UNEQUAL\n      } else {\n        expectedIsMissing = compareComplexShape(this.key, expected.key) !== UNEQUAL\n      }\n\n      expected = rhsFork.shared()\n    }\n\n    let actualIsExtraneous = false\n    if (this.tag === initialExpected.tag) {\n      if (initialExpected.keyIsPrimitive) {\n        let actual = this\n        while (!actualIsExtraneous && actual !== null && this.tag === actual.tag) {\n          if (actual.keyIsPrimitive) {\n            actualIsExtraneous = initialExpected.key.compare(actual.key) === DEEP_EQUAL\n          }\n\n          actual = lhsFork.shared()\n        }\n      } else {\n        let actual = this\n        while (!actualIsExtraneous && actual !== null && this.tag === actual.tag) {\n          if (!actual.keyIsPrimitive) {\n            actualIsExtraneous = compareComplexShape(actual.key, initialExpected.key) !== UNEQUAL\n          }\n\n          actual = lhsFork.shared()\n        }\n      }\n    }\n\n    if (actualIsExtraneous && !expectedIsMissing) {\n      return {\n        actualIsExtraneous: true,\n        lhsRecursor: lhsFork.recursor,\n        rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)\n      }\n    }\n\n    if (expectedIsMissing && !actualIsExtraneous) {\n      return {\n        expectedIsMissing: true,\n        lhsRecursor: recursorUtils.unshift(lhsFork.recursor, this),\n        rhsRecursor: rhsFork.recursor\n      }\n    }\n\n    let mustRecurse = false\n    if (!this.keyIsPrimitive && !initialExpected.keyIsPrimitive) {\n      if (this.valueIsPrimitive || initialExpected.valueIsPrimitive) {\n        mustRecurse = this.value.compare(initialExpected.value) !== UNEQUAL\n      } else {\n        mustRecurse = compareComplexShape(this.value, initialExpected.value) !== UNEQUAL\n      }\n    }\n\n    return {\n      mustRecurse,\n      isUnequal: !mustRecurse,\n      lhsRecursor: lhsFork.recursor,\n      rhsRecursor: rhsFork.recursor\n    }\n  }\n\n  serialize () {\n    return [this.keyIsPrimitive, this.valueIsPrimitive]\n  }\n}\nObject.defineProperty(MapEntry.prototype, 'isMapEntry', { value: true })\nObject.defineProperty(MapEntry.prototype, 'tag', { value: tag })\n"},"hash":"d334e1a294bb6cb81a17a698eeb3ace6"}