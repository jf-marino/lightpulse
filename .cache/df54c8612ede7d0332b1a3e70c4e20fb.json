{"dependencies":[{"name":"is-generator-fn","loc":{"line":2,"column":30}},{"name":"co-with-promise","loc":{"line":3,"column":19}},{"name":"concordance","loc":{"line":4,"column":28}},{"name":"observable-to-promise","loc":{"line":5,"column":36}},{"name":"is-promise","loc":{"line":6,"column":26}},{"name":"is-observable","loc":{"line":7,"column":29}},{"name":"plur","loc":{"line":8,"column":21}},{"name":"./assert","loc":{"line":9,"column":23}},{"name":"./globals","loc":{"line":10,"column":24}},{"name":"./concordance-options","loc":{"line":11,"column":35}}],"generated":{"js":"\"use strict\";const t=require(\"is-generator-fn\"),s=require(\"co-with-promise\"),e=require(\"concordance\"),r=require(\"observable-to-promise\"),i=require(\"is-promise\"),n=require(\"is-observable\"),o=require(\"plur\"),a=require(\"./assert\"),h=require(\"./globals\"),l=require(\"./concordance-options\").default;function c(t,s){return{label:t,formatted:e.format(s,l)}}class d{constructor(t){this._test=t}}const u=t=>{const s=Error.stackTraceLimit;Error.stackTraceLimit=1;const e={};return Error.captureStackTrace(e,t),Error.stackTraceLimit=s,e.stack};class f{constructor(t){Object.defineProperties(this,{_test:{value:t},skip:{value:new d(t)}})}plan(t){this._test.plan(t,u(this.plan))}get end(){const t=this._test.bindEndCallback(),s=e=>t(e,u(s));return s}get title(){return this._test.title}get context(){const t=this._test.contextRef;return t&&t.context}set context(t){const s=this._test.contextRef;s?s.context=t:this._test.saveFirstError(new Error(`\\`t.context\\` is not available in ${this._test.metadata.type} tests`))}_throwsArgStart(t,s,e){this._test.trackThrows({assertion:t,file:s,line:e})}_throwsArgEnd(){this._test.trackThrows(null)}}{const t=a.wrapAssertions({log(t,s){t._test.addLog(s)},pass(t){t._test.countPassedAssertion()},pending(t,s){t._test.addPendingAssertion(s)},fail(t,s){t._test.addFailedAssertion(s)}});function p(){this._test.countPassedAssertion()}Object.assign(f.prototype,t),Object.keys(t).forEach(t=>{d.prototype[t]=p})}class E{constructor(e){this.contextRef=e.contextRef,this.failWithoutAssertions=e.failWithoutAssertions,this.fn=t(e.fn)?s.wrap(e.fn):e.fn,this.metadata=e.metadata,this.onResult=e.onResult,this.title=e.title,this.logs=[],this.snapshotInvocationCount=0,this.compareWithSnapshot=(t=>{const s=t.id||this.title,r=t.expected,i=t.id?0:this.snapshotInvocationCount++,n=t.id?\"\":t.message||`Snapshot ${this.snapshotInvocationCount}`;return e.compareTestSnapshot({belongsTo:s,expected:r,index:i,label:n})}),this.assertCount=0,this.assertError=void 0,this.calledEnd=!1,this.duration=null,this.endCallbackFinisher=null,this.finishDueToAttributedError=null,this.finishDueToInactivity=null,this.finishing=!1,this.pendingAssertionCount=0,this.pendingThrowsAssertion=null,this.planCount=null,this.startedAt=0}bindEndCallback(){if(this.metadata.callback)return(t,s)=>{this.endCallback(t,s)};throw new Error('`t.end()`` is not supported in this context. To use `t.end()` as a callback, you must use \"callback mode\" via `test.cb(testName, fn)`')}endCallback(t,s){this.calledEnd?this.saveFirstError(new Error(\"`t.end()` called more than once\")):(this.calledEnd=!0,t&&this.saveFirstError(new a.AssertionError({actual:t,message:\"Callback called with an error\",stack:s,values:[c(\"Callback called with an error:\",t)]})),this.endCallbackFinisher&&this.endCallbackFinisher())}createExecutionContext(){return new f(this)}countPassedAssertion(){this.finishing&&this.saveFirstError(new Error(\"Assertion passed, but test has already finished\")),this.assertCount++}addLog(t){this.logs.push(t)}addPendingAssertion(t){this.finishing&&this.saveFirstError(new Error(\"Assertion passed, but test has already finished\")),this.assertCount++,this.pendingAssertionCount++,t.catch(t=>this.saveFirstError(t)).then(()=>this.pendingAssertionCount--)}addFailedAssertion(t){this.finishing&&this.saveFirstError(new Error(\"Assertion failed, but test has already finished\")),this.assertCount++,this.saveFirstError(t)}saveFirstError(t){this.assertError||(this.assertError=t)}plan(t,s){if(\"number\"!=typeof t)throw new TypeError(\"Expected a number\");this.planCount=t,this.planStack=s}verifyPlan(){this.assertError||null===this.planCount||this.planCount===this.assertCount||this.saveFirstError(new a.AssertionError({assertion:\"plan\",message:`Planned for ${this.planCount} ${o(\"assertion\",this.planCount)}, but got ${this.assertCount}.`,operator:\"===\",stack:this.planStack}))}verifyAssertions(){this.assertError||(this.failWithoutAssertions&&!this.calledEnd&&null===this.planCount&&0===this.assertCount?this.saveFirstError(new Error(\"Test finished without running any assertions\")):this.pendingAssertionCount>0&&this.saveFirstError(new Error(\"Test finished, but an assertion is still pending\")))}trackThrows(t){this.pendingThrowsAssertion=t}detectImproperThrows(t){if(!this.pendingThrowsAssertion)return!1;const s=this.pendingThrowsAssertion;this.pendingThrowsAssertion=null;const e=[];return t&&e.push(c(`The following error was thrown, possibly before \\`t.${s.assertion}()\\` could be called:`,t)),this.saveFirstError(new a.AssertionError({assertion:s.assertion,fixedSource:{file:s.file,line:s.line},improperUsage:!0,message:`Improper usage of \\`t.${s.assertion}()\\` detected`,stack:t instanceof Error&&t.stack,values:e})),!0}waitForPendingThrowsAssertion(){return new Promise(t=>{this.finishDueToAttributedError=(()=>{t(this.finishPromised())}),this.finishDueToInactivity=(()=>{this.detectImproperThrows(),t(this.finishPromised())}),h.setTimeout(()=>this.finishDueToInactivity(),1e3).unref()})}attributeLeakedError(t){return!!this.detectImproperThrows(t)&&(this.finishDueToAttributedError(),!0)}callFn(){try{return{ok:!0,retval:this.fn(this.createExecutionContext())}}catch(t){return{ok:!1,error:t}}}run(){this.startedAt=h.now();const t=this.callFn();if(!t.ok)return this.detectImproperThrows(t.error)||this.saveFirstError(new a.AssertionError({message:\"Error thrown in test\",stack:t.error instanceof Error&&t.error.stack,values:[c(\"Error thrown in test:\",t.error)]})),this.finish();const s=n(t.retval),e=i(t.retval);let o;if(s?o=r(t.retval):e&&(o=Promise.resolve(t.retval)),this.metadata.callback){if(s||e){const t=s?\"observables\":\"promises\";return this.saveFirstError(new Error(`Do not return ${t} from tests declared via \\`test.cb(...)\\`, if you want to return a promise simply declare the test via \\`test(...)\\``)),this.finish()}return this.calledEnd?this.finish():new Promise(t=>{this.endCallbackFinisher=(()=>{t(this.finishPromised())}),this.finishDueToAttributedError=(()=>{t(this.finishPromised())}),this.finishDueToInactivity=(()=>{this.saveFirstError(new Error(\"`t.end()` was never called\")),t(this.finishPromised())})})}return o?new Promise(t=>{this.finishDueToAttributedError=(()=>{t(this.finishPromised())}),this.finishDueToInactivity=(()=>{const e=s?new Error(\"Observable returned by test never completed\"):new Error(\"Promise returned by test never resolved\");this.saveFirstError(e),t(this.finishPromised())}),o.catch(t=>{this.detectImproperThrows(t)||this.saveFirstError(new a.AssertionError({message:\"Rejected promise returned by test\",stack:t instanceof Error&&t.stack,values:[c(\"Rejected promise returned by test. Reason:\",t)]}))}).then(()=>t(this.finishPromised()))}):this.finish()}finish(){if(this.finishing=!0,!this.assertError&&this.pendingThrowsAssertion)return this.waitForPendingThrowsAssertion();this.verifyPlan(),this.verifyAssertions(),this.duration=h.now()-this.startedAt;let t=this.assertError,s=!t;return this.metadata.failing&&(t=(s=!s)?void 0:new Error(\"Test was expected to fail, but succeeded, you should stop marking the test as failing\")),this.onResult({passed:s,result:this,reason:t}),s}finishPromised(){return new Promise(t=>{t(this.finish())})}}module.exports=E;"},"hash":"7899baa9b0b857e52ceeeb9856ef95e1"}