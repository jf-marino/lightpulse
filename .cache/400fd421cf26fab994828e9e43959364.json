{"dependencies":[{"name":"arrify","loc":{"line":3,"column":23}},{"name":"./diffShallow","loc":{"line":4,"column":28}},{"name":"./escapeText","loc":{"line":5,"column":27}}],"generated":{"js":"'use strict'\n\nconst arrify = require('arrify')\nconst diffShallow = require('./diffShallow')\nconst escapeText = require('./escapeText')\n\nfunction factory (api, reactTags) {\n  const tag = Symbol('@concordance/react.ElementValue')\n\n  function customPropertyFormatter (theme, indent, key, value) {\n    const separator = theme.react.attribute.separator + theme.react.attribute.value.openBracket\n    if (value.isSingle) {\n      return value\n        .withFirstPrefixed(key.formatAsKey(theme) + separator)\n        .withLastPostfixed(theme.react.attribute.value.closeBracket)\n    }\n\n    return api.lineBuilder.first(key.formatAsKey(theme) + separator)\n      .concat(value.withFirstPrefixed(indent.increase()).stripFlags())\n      .append(api.lineBuilder.last(indent + theme.react.attribute.value.closeBracket))\n  }\n\n  function themeProperty (theme) {\n    theme.property.increaseValueIndent = true\n    theme.property.customFormat = customPropertyFormatter\n  }\n\n  function themeStringProperty (theme) {\n    theme.property.separator = theme.react.attribute.separator\n    theme.property.after = ''\n    Object.assign(theme.string.line, theme.react.attribute.value.string.line)\n  }\n\n  function customItemFormatter (theme, indent, value) {\n    if (value.isSingle) {\n      return value\n        .withFirstPrefixed(theme.react.child.openBracket)\n        .withLastPostfixed(theme.react.child.closeBracket)\n    }\n\n    return api.lineBuilder.first(theme.react.child.openBracket)\n      .concat(value.withFirstPrefixed(indent.increase()).stripFlags())\n      .append(api.lineBuilder.last(indent + theme.react.child.closeBracket))\n  }\n\n  function themeChild (theme) {\n    theme.item.increaseValueIndent = true\n    theme.item.customFormat = customItemFormatter\n  }\n\n  function themeReactChild (theme) {\n    theme.item.after = ''\n  }\n\n  function themeStringChild (theme) {\n    theme.item.after = ''\n    Object.assign(theme.string, theme.react.child.string)\n  }\n\n  function describe (props) {\n    const element = props.value\n\n    const type = element.type\n    const hasTypeFn = typeof type === 'function'\n    const typeFn = hasTypeFn ? type : null\n    const name = hasTypeFn ? type.displayName || type.name : type\n\n    const children = arrify(element.props.children)\n\n    const properties = Object.assign({}, element.props)\n    delete properties.children\n    if (element.key !== null) {\n      properties.key = element.key\n    }\n    const hasProperties = Object.keys(properties).length > 0\n\n    return new DescribedElementValue(Object.assign({\n      children,\n      hasProperties,\n      hasTypeFn,\n      name,\n      properties,\n      typeFn,\n      isList: children.length > 0\n    }, props))\n  }\n\n  function deserialize (state, recursor) {\n    return new DeserializedElementValue(state, recursor)\n  }\n\n  class ElementValue extends api.ObjectValue {\n    constructor (props) {\n      super(props)\n      this.name = props.name\n      this.hasProperties = props.hasProperties\n      this.hasTypeFn = props.hasTypeFn\n\n      this.hasChildren = this.isList\n    }\n\n    compare (expected) {\n      return this.tag === expected.tag && this.name === expected.name\n        ? api.SHALLOW_EQUAL\n        : api.UNEQUAL\n    }\n\n    formatName (theme) {\n      const formatted = api.wrapFromTheme(theme.react.tagName, this.name)\n      return this.hasTypeFn\n        ? formatted + theme.react.functionType\n        : formatted\n    }\n\n    compareNames (expected) {\n      return this.name === expected.name && this.hasTypeFn === expected.hasTypeFn\n    }\n\n    formatShallow (theme, indent) {\n      const childBuffer = api.lineBuilder.buffer()\n      const propertyBuffer = api.lineBuilder.buffer()\n\n      return {\n        append (formatted, origin) {\n          if (origin.isItem === true) {\n            childBuffer.append(formatted)\n          } else {\n            propertyBuffer.append(formatted)\n          }\n        },\n\n        finalize: () => {\n          const name = this.formatName(theme)\n          const openTag = theme.react.openTag\n\n          if (!this.hasChildren && !this.hasProperties) {\n            return api.lineBuilder.single(openTag.start + name + openTag.selfCloseVoid + openTag.end)\n          }\n\n          const innerIndentation = indent.increase()\n          const children = childBuffer.withFirstPrefixed(innerIndentation).stripFlags()\n          const properties = propertyBuffer.withFirstPrefixed(innerIndentation).stripFlags()\n\n          const result = api.lineBuilder.buffer()\n          if (this.hasProperties) {\n            result\n              .append(api.lineBuilder.first(openTag.start + name))\n              .append(properties)\n\n            if (this.hasChildren) {\n              result.append(api.lineBuilder.line(indent + openTag.end))\n            } else {\n              result.append(api.lineBuilder.last(indent + openTag.selfClose + openTag.end))\n            }\n          } else {\n            result.append(api.lineBuilder.first(openTag.start + name + openTag.end))\n          }\n\n          if (this.hasChildren) {\n            result\n              .append(children)\n              .append(api.lineBuilder.last(indent + api.wrapFromTheme(theme.react.closeTag, name)))\n          }\n\n          return result\n        },\n\n        maxDepth: () => {\n          const name = this.formatName(theme)\n          const openTag = theme.react.openTag\n\n          if (!this.hasChildren && !this.hasProperties) {\n            return api.lineBuilder.single(openTag.start + name + openTag.selfCloseVoid + openTag.end)\n          }\n\n          let str = openTag.start + name\n          if (this.hasProperties) {\n            str += theme.maxDepth\n            if (this.hasChildren) {\n              str += openTag.end\n            } else {\n              str += ' ' + openTag.selfClose + openTag.end\n            }\n          } else {\n            str += openTag.end\n          }\n\n          if (this.hasChildren) {\n            str += theme.maxDepth + api.wrapFromTheme(theme.react.closeTag, name)\n          }\n\n          return api.lineBuilder.single(str)\n        },\n\n        shouldFormat (subject) {\n          return subject.isItem === true || subject.isProperty === true\n        },\n\n        increaseIndent: true\n      }\n    }\n\n    prepareDiff (expected) {\n      return {\n        compareResult: this.tag === expected.tag\n          ? api.SHALLOW_EQUAL\n          : api.UNEQUAL\n      }\n    }\n\n    diffShallow (expected, theme, indent) {\n      return diffShallow(api, this, expected, theme, indent)\n    }\n\n    serialize () {\n      return [this.name, this.hasProperties, this.hasTypeFn, super.serialize()]\n    }\n  }\n  Object.defineProperty(ElementValue.prototype, 'tag', {value: tag})\n\n  function modifyThemes (recursor) {\n    return api.mapRecursor(recursor, next => {\n      let modifier\n      if (next.isItem === true) {\n        if (next.tag === api.descriptorTags.primitiveItem && next.value.tag === api.descriptorTags.string) {\n          modifier = themeStringChild\n        } else if (next.tag === api.descriptorTags.complexItem && reactTags.has(next.value.tag)) {\n          modifier = themeReactChild\n        } else {\n          modifier = themeChild\n        }\n      } else if (next.isProperty === true) {\n        if (\n          next.tag === api.descriptorTags.primitiveProperty &&\n          next.value.tag === api.descriptorTags.string &&\n          !next.value.includesLinebreaks\n        ) {\n          modifier = themeStringProperty\n        } else {\n          modifier = themeProperty\n        }\n      }\n\n      return modifier\n        ? api.modifyTheme(next, modifier)\n        : next\n    })\n  }\n\n  function DescribedMixin (base) {\n    return class extends api.DescribedMixin(base) {\n      constructor (props) {\n        super(props)\n        this.children = props.children\n        this.properties = props.properties\n        this.typeFn = props.typeFn\n      }\n\n      compare (expected) {\n        const result = super.compare(expected)\n        return result === api.SHALLOW_EQUAL && this.typeFn !== expected.typeFn\n          ? api.UNEQUAL\n          : result\n      }\n\n      compareNames (expected) {\n        return super.compareNames(expected) && this.typeFn === expected.typeFn\n      }\n\n      createPropertyRecursor () {\n        // Symbols are not valid property keys for React elements. This code\n        // also assumes that the keys can be formatted as JSX-like attribute\n        // names. Keys are not pre-escaped before being passed to Concordance's\n        // property descriptor.\n        const keys = Object.keys(this.properties).sort()\n        const size = keys.length\n\n        let index = 0\n        const next = () => {\n          if (index === size) return null\n\n          const key = keys[index++]\n          // Note that string values are not specifically escaped such that the\n          // output is valid JSX.\n          return this.describeProperty(key, this.describeAny(this.properties[key]))\n        }\n\n        return {size, next}\n      }\n\n      createListRecursor () {\n        if (!this.isList) return super.createListRecursor()\n\n        const size = this.children.length\n\n        let index = 0\n        const next = () => {\n          if (index === size) return null\n\n          const current = index++\n          const child = this.children[current]\n          const type = typeof child\n          let descriptor\n          if (type === 'string') {\n            descriptor = this.describeAny(escapeText(child))\n          } else {\n            descriptor = this.describeAny(child)\n          }\n\n          return this.describeItem(current, descriptor)\n        }\n\n        return {size, next}\n      }\n\n      createRecursor () {\n        return modifyThemes(super.createRecursor())\n      }\n    }\n  }\n\n  function DeserializedMixin (base) {\n    return class extends api.DeserializedMixin(base) {\n      constructor (state, recursor) {\n        super(state[3], recursor)\n        this.name = state[0]\n        this.hasProperties = state[1]\n        this.hasTypeFn = state[2]\n      }\n\n      createRecursor () {\n        return modifyThemes(super.createRecursor())\n      }\n    }\n  }\n\n  const DescribedElementValue = DescribedMixin(ElementValue)\n  const DeserializedElementValue = DeserializedMixin(ElementValue)\n\n  return {\n    DescribedMixin,\n    DeserializedMixin,\n    ElementValue,\n    describe,\n    deserialize,\n    tag\n  }\n}\nmodule.exports = factory\n"},"hash":"98ec7edac061e65f764a26738dd1fd3f"}