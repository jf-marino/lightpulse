{"dependencies":[{"name":"lodash.flattendeep","loc":{"line":3,"column":28}},{"name":"buffer"}],"generated":{"js":"var Buffer = require(\"buffer\").Buffer;\n'use strict'\n\nconst flattenDeep = require('lodash.flattendeep')\n\n// Indexes are hexadecimal to make reading the binary output easier.\nconst valueTypes = {\n  zero: 0x00,\n  int8: 0x01,  // Note that the hex value equals the number of bytes required\n  int16: 0x02, // to store the integer.\n  int24: 0x03,\n  int32: 0x04,\n  int40: 0x05,\n  int48: 0x06,\n  // Leave room for int56 and int64\n  numberString: 0x09,\n  negativeZero: 0x0A,\n  notANumber: 0x0B,\n  infinity: 0x0C,\n  negativeInfinity: 0x0D,\n  undefined: 0x0E,\n  null: 0x0F,\n  true: 0x10,\n  false: 0x11,\n  utf8: 0x12,\n  bytes: 0x13,\n  list: 0x14,\n  descriptor: 0x15\n}\n\nconst descriptorSymbol = Symbol('descriptor')\nexports.descriptorSymbol = descriptorSymbol\n\nfunction encodeInteger (type, value) {\n  const encoded = Buffer.alloc(type)\n  encoded.writeIntLE(value, 0, type)\n  return [type, encoded]\n}\n\nfunction encodeValue (value) {\n  if (Object.is(value, 0)) return valueTypes.zero\n  if (Object.is(value, -0)) return valueTypes.negativeZero\n  if (Object.is(value, NaN)) return valueTypes.notANumber\n  if (value === Infinity) return valueTypes.infinity\n  if (value === -Infinity) return valueTypes.negativeInfinity\n  if (value === undefined) return valueTypes.undefined\n  if (value === null) return valueTypes.null\n  if (value === true) return valueTypes.true\n  if (value === false) return valueTypes.false\n\n  const type = typeof value\n  if (type === 'number') {\n    if (Number.isInteger(value)) {\n      // The integer types are signed, so int8 can only store 7 bits, int16\n      // only 15, etc.\n      if (value >= -0x80 && value < 0x80) return encodeInteger(valueTypes.int8, value)\n      if (value >= -0x8000 && value < 0x8000) return encodeInteger(valueTypes.int16, value)\n      if (value >= -0x800000 && value < 0x800000) return encodeInteger(valueTypes.int24, value)\n      if (value >= -0x80000000 && value < 0x80000000) return encodeInteger(valueTypes.int32, value)\n      if (value >= -0x8000000000 && value < 0x8000000000) return encodeInteger(valueTypes.int40, value)\n      if (value >= -0x800000000000 && value < 0x800000000000) return encodeInteger(valueTypes.int48, value)\n      // Fall through to encoding the value as a number string.\n    }\n\n    const encoded = Buffer.from(String(value), 'utf8')\n    return [valueTypes.numberString, encodeValue(encoded.length), encoded]\n  }\n\n  if (type === 'string') {\n    const encoded = Buffer.from(value, 'utf8')\n    return [valueTypes.utf8, encodeValue(encoded.length), encoded]\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return [valueTypes.bytes, encodeValue(value.byteLength), value]\n  }\n\n  if (Array.isArray(value)) {\n    return [\n      value[descriptorSymbol] === true ? valueTypes.descriptor : valueTypes.list,\n      encodeValue(value.length),\n      value.map(encodeValue)\n    ]\n  }\n\n  const hex = `0x${type.toString(16).toUpperCase()}`\n  throw new TypeError(`Unexpected value with type ${hex}`)\n}\n\nfunction decodeValue (buffer, byteOffset) {\n  const type = buffer.readUInt8(byteOffset)\n  byteOffset += 1\n\n  if (type === valueTypes.zero) return { byteOffset, value: 0 }\n  if (type === valueTypes.negativeZero) return { byteOffset, value: -0 }\n  if (type === valueTypes.notANumber) return { byteOffset, value: NaN }\n  if (type === valueTypes.infinity) return { byteOffset, value: Infinity }\n  if (type === valueTypes.negativeInfinity) return { byteOffset, value: -Infinity }\n  if (type === valueTypes.undefined) return { byteOffset, value: undefined }\n  if (type === valueTypes.null) return { byteOffset, value: null }\n  if (type === valueTypes.true) return { byteOffset, value: true }\n  if (type === valueTypes.false) return { byteOffset, value: false }\n\n  if (\n    type === valueTypes.int8 || type === valueTypes.int16 || type === valueTypes.int24 ||\n    type === valueTypes.int32 || type === valueTypes.int40 || type === valueTypes.int48\n  ) {\n    const value = buffer.readIntLE(byteOffset, type)\n    byteOffset += type\n    return { byteOffset, value }\n  }\n\n  if (type === valueTypes.numberString || type === valueTypes.utf8 || type === valueTypes.bytes) {\n    const length = decodeValue(buffer, byteOffset)\n    const start = length.byteOffset\n    const end = start + length.value\n\n    if (type === valueTypes.numberString) {\n      const value = Number(buffer.toString('utf8', start, end))\n      return { byteOffset: end, value }\n    }\n\n    if (type === valueTypes.utf8) {\n      const value = buffer.toString('utf8', start, end)\n      return { byteOffset: end, value }\n    }\n\n    const value = buffer.slice(start, end)\n    return { byteOffset: end, value }\n  }\n\n  if (type === valueTypes.list || type === valueTypes.descriptor) {\n    const length = decodeValue(buffer, byteOffset)\n    byteOffset = length.byteOffset\n\n    const value = new Array(length.value)\n    if (type === valueTypes.descriptor) {\n      value[descriptorSymbol] = true\n    }\n\n    for (let index = 0; index < length.value; index++) {\n      const item = decodeValue(buffer, byteOffset)\n      byteOffset = item.byteOffset\n      value[index] = item.value\n    }\n\n    return { byteOffset, value }\n  }\n\n  const hex = `0x${type.toString(16).toUpperCase()}`\n  throw new TypeError(`Could not decode type ${hex}`)\n}\n\nfunction buildBuffer (numberOrArray) {\n  if (typeof numberOrArray === 'number') {\n    const byte = Buffer.alloc(1)\n    byte.writeUInt8(numberOrArray)\n    return byte\n  }\n\n  const array = flattenDeep(numberOrArray)\n  const buffers = new Array(array.length)\n  let byteLength = 0\n  for (let index = 0; index < array.length; index++) {\n    if (typeof array[index] === 'number') {\n      byteLength += 1\n      const byte = Buffer.alloc(1)\n      byte.writeUInt8(array[index])\n      buffers[index] = byte\n    } else {\n      byteLength += array[index].byteLength\n      buffers[index] = array[index]\n    }\n  }\n  return Buffer.concat(buffers, byteLength)\n}\n\nfunction encode (serializerVersion, rootRecord, usedPlugins) {\n  const buffers = []\n  let byteOffset = 0\n\n  const versionHeader = Buffer.alloc(2)\n  versionHeader.writeUInt16LE(serializerVersion)\n  buffers.push(versionHeader)\n  byteOffset += versionHeader.byteLength\n\n  const rootOffset = Buffer.alloc(4)\n  buffers.push(rootOffset)\n  byteOffset += rootOffset.byteLength\n\n  const numPlugins = buildBuffer(encodeValue(usedPlugins.size))\n  buffers.push(numPlugins)\n  byteOffset += numPlugins.byteLength\n\n  for (const name of usedPlugins.keys()) {\n    const plugin = usedPlugins.get(name)\n    const record = buildBuffer([\n      encodeValue(name),\n      encodeValue(plugin.serializerVersion)\n    ])\n    buffers.push(record)\n    byteOffset += record.byteLength\n  }\n\n  const queue = [rootRecord]\n  const pointers = [rootOffset]\n  while (queue.length > 0) {\n    pointers.shift().writeUInt32LE(byteOffset, 0)\n\n    const record = queue.shift()\n    const recordHeader = buildBuffer([\n      encodeValue(record.pluginIndex),\n      encodeValue(record.id),\n      encodeValue(record.children.length)\n    ])\n    buffers.push(recordHeader)\n    byteOffset += recordHeader.byteLength\n\n    // Add pointers before encoding the state. This allows, if it ever becomes\n    // necessary, for records to be extracted from a buffer without having to\n    // parse the (variable length) state field.\n    for (const child of record.children) {\n      queue.push(child)\n\n      const pointer = Buffer.alloc(4)\n      pointers.push(pointer)\n      buffers.push(pointer)\n      byteOffset += 4\n    }\n\n    const state = buildBuffer(encodeValue(record.state))\n    buffers.push(state)\n    byteOffset += state.byteLength\n  }\n\n  return Buffer.concat(buffers, byteOffset)\n}\nexports.encode = encode\n\nfunction decodePlugins (buffer) {\n  const $numPlugins = decodeValue(buffer, 0)\n  let byteOffset = $numPlugins.byteOffset\n\n  const usedPlugins = new Map()\n  const lastIndex = $numPlugins.value\n  for (let index = 1; index <= lastIndex; index++) {\n    const $name = decodeValue(buffer, byteOffset)\n    const name = $name.value\n    byteOffset = $name.byteOffset\n\n    const serializerVersion = decodeValue(buffer, byteOffset).value\n    usedPlugins.set(index, {name, serializerVersion})\n  }\n\n  return usedPlugins\n}\nexports.decodePlugins = decodePlugins\n\nfunction decodeRecord (buffer, byteOffset) {\n  const $pluginIndex = decodeValue(buffer, byteOffset)\n  const pluginIndex = $pluginIndex.value\n  byteOffset = $pluginIndex.byteOffset\n\n  const $id = decodeValue(buffer, byteOffset)\n  const id = $id.value\n  byteOffset = $id.byteOffset\n\n  const $numPointers = decodeValue(buffer, byteOffset)\n  const numPointers = $numPointers.value\n  byteOffset = $numPointers.byteOffset\n\n  const pointerAddresses = new Array(numPointers)\n  for (let index = 0; index < numPointers; index++) {\n    pointerAddresses[index] = buffer.readUInt32LE(byteOffset)\n    byteOffset += 4\n  }\n\n  const state = decodeValue(buffer, byteOffset).value\n  return {id, pluginIndex, state, pointerAddresses}\n}\nexports.decodeRecord = decodeRecord\n\nfunction extractVersion (buffer) {\n  return buffer.readUInt16LE(0)\n}\nexports.extractVersion = extractVersion\n\nfunction decode (buffer) {\n  const rootOffset = buffer.readUInt32LE(2)\n  const pluginBuffer = buffer.slice(6, rootOffset)\n  const rootRecord = decodeRecord(buffer, rootOffset)\n  return {pluginBuffer, rootRecord}\n}\nexports.decode = decode\n"},"hash":"c1426eaf769ffda38151b5f3f40c2028"}