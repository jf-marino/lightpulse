{"dependencies":[{"name":"function-name-support","loc":{"line":3,"column":36}},{"name":"../constants","loc":{"line":5,"column":26}},{"name":"../getObjectKeys","loc":{"line":6,"column":30}},{"name":"../formatUtils","loc":{"line":7,"column":32}},{"name":"../hasLength","loc":{"line":8,"column":26}},{"name":"../recursorUtils","loc":{"line":9,"column":30}},{"name":"../metaDescriptors/stats","loc":{"line":10,"column":22}}],"generated":{"js":"'use strict'\n\nconst functionNameSupport = require('function-name-support')\n\nconst constants = require('../constants')\nconst getObjectKeys = require('../getObjectKeys')\nconst ObjectFormatter = require('../formatUtils').ObjectFormatter\nconst hasLength = require('../hasLength')\nconst recursorUtils = require('../recursorUtils')\nconst stats = require('../metaDescriptors/stats')\n\nconst DEEP_EQUAL = constants.DEEP_EQUAL\nconst SHALLOW_EQUAL = constants.SHALLOW_EQUAL\nconst UNEQUAL = constants.UNEQUAL\n\nfunction describe (props) {\n  const isArray = props.stringTag === 'Array'\n  const object = props.value\n  return new DescribedObjectValue(Object.assign({\n    isArray,\n    isIterable: object[Symbol.iterator] !== undefined,\n    isList: isArray || hasLength(object)\n  }, props))\n}\nexports.describe = describe\n\nfunction deserialize (state, recursor) {\n  return new DeserializedObjectValue(state, recursor)\n}\nexports.deserialize = deserialize\n\nconst tag = Symbol('ObjectValue')\nexports.tag = tag\n\nclass ObjectValue {\n  constructor (props) {\n    this.ctor = props.ctor\n    this.pointer = props.pointer\n    this.stringTag = props.stringTag\n\n    this.isArray = props.isArray === true\n    this.isIterable = props.isIterable === true\n    this.isList = props.isList === true\n  }\n\n  compare (expected) {\n    if (this.tag !== expected.tag) return UNEQUAL\n    if (this.stringTag !== expected.stringTag || !this.hasSameCtor(expected)) return UNEQUAL\n    return SHALLOW_EQUAL\n  }\n\n  hasSameCtor (expected) {\n    return this.ctor === expected.ctor\n  }\n\n  formatShallow (theme, indent) {\n    return new ObjectFormatter(this, theme, indent)\n  }\n\n  serialize () {\n    return [\n      this.ctor, this.pointer, this.stringTag,\n      this.isArray, this.isIterable, this.isList,\n      functionNameSupport.bitFlags\n    ]\n  }\n}\nObject.defineProperty(ObjectValue.prototype, 'isComplex', { value: true })\nObject.defineProperty(ObjectValue.prototype, 'tag', { value: tag })\nexports.ObjectValue = ObjectValue\n\nconst DescribedObjectValue = DescribedMixin(ObjectValue)\nconst DeserializedObjectValue = DeserializedMixin(ObjectValue)\n\nfunction DescribedMixin (base) {\n  return class extends base {\n    constructor (props) {\n      super(props)\n\n      this.value = props.value\n      this.describeAny = props.describeAny\n      this.describeItem = props.describeItem\n      this.describeMapEntry = props.describeMapEntry\n      this.describeProperty = props.describeProperty\n\n      this.iterableState = null\n      this.listState = null\n      this.propertyState = null\n    }\n\n    compare (expected) {\n      return this.value === expected.value\n        ? DEEP_EQUAL\n        : super.compare(expected)\n    }\n\n    createPropertyRecursor () {\n      const objectKeys = getObjectKeys(this.value, this.isList ? this.value.length : 0)\n      const size = objectKeys.size\n      if (size === 0) return recursorUtils.NOOP_RECURSOR\n\n      let index = 0\n      const next = () => {\n        if (index === size) return null\n\n        const key = objectKeys.keys[index++]\n        return this.describeProperty(key, this.describeAny(this.value[key]))\n      }\n\n      return { size, next }\n    }\n\n    createListRecursor () {\n      if (!this.isList) return recursorUtils.NOOP_RECURSOR\n\n      const size = this.value.length\n      if (size === 0) return recursorUtils.NOOP_RECURSOR\n\n      let index = 0\n      const next = () => {\n        if (index === size) return null\n\n        const current = index\n        index++\n        return this.describeItem(current, this.describeAny(this.value[current]))\n      }\n\n      return { size, next }\n    }\n\n    createIterableRecursor () {\n      if (this.isArray || !this.isIterable) return recursorUtils.NOOP_RECURSOR\n\n      const iterator = this.value[Symbol.iterator]()\n      let first = iterator.next()\n\n      let done = false\n      let size = -1\n      if (first.done) {\n        if (first.value === undefined) {\n          size = 0\n          done = true\n        } else {\n          size = 1\n        }\n      }\n\n      let index = 0\n      const next = () => {\n        if (done) return null\n\n        while (!done) {\n          const current = first || iterator.next()\n          if (current === first) {\n            first = null\n          }\n          if (current.done) {\n            done = true\n          }\n\n          const item = current.value\n          if (done && item === undefined) return null\n\n          if (this.isList && this.value[index] === item) {\n            index++\n          } else {\n            return this.describeItem(index++, this.describeAny(item))\n          }\n        }\n      }\n\n      return { size, next }\n    }\n\n    createRecursor () {\n      let recursedProperty = false\n      let recursedList = false\n      let recursedIterable = false\n\n      let recursor = null\n      return () => {\n        let retval = null\n        do {\n          if (recursor !== null) {\n            retval = recursor.next()\n            if (retval === null) {\n              recursor = null\n            }\n          }\n\n          while (recursor === null && (!recursedList || !recursedProperty || !recursedIterable)) {\n            // Prioritize recursing lists\n            if (!recursedList) {\n              const replay = recursorUtils.replay(this.listState, () => this.createListRecursor())\n              this.listState = replay.state\n              recursor = replay.recursor\n              recursedList = true\n              if (recursor !== recursorUtils.NOOP_RECURSOR) {\n                retval = stats.describeListRecursor(recursor)\n              }\n            } else if (!recursedProperty) {\n              const replay = recursorUtils.replay(this.propertyState, () => this.createPropertyRecursor())\n              this.propertyState = replay.state\n              recursor = replay.recursor\n              recursedProperty = true\n              if (recursor !== recursorUtils.NOOP_RECURSOR) {\n                retval = stats.describePropertyRecursor(recursor)\n              }\n            } else if (!recursedIterable) {\n              const replay = recursorUtils.replay(this.iterableState, () => this.createIterableRecursor())\n              this.iterableState = replay.state\n              recursor = replay.recursor\n              recursedIterable = true\n              if (recursor !== recursorUtils.NOOP_RECURSOR) {\n                retval = stats.describeIterableRecursor(recursor)\n              }\n            }\n          }\n        } while (recursor !== null && retval === null)\n\n        return retval\n      }\n    }\n  }\n}\nexports.DescribedMixin = DescribedMixin\n\nfunction DeserializedMixin (base) {\n  return class extends base {\n    constructor (state, recursor) {\n      super({\n        ctor: state[0],\n        pointer: state[1],\n        stringTag: state[2],\n        isArray: state[3],\n        isIterable: state[4],\n        isList: state[5]\n      })\n\n      this.functionNameSupportFlags = state[6]\n      this.deserializedRecursor = recursor\n      this.replayState = null\n    }\n\n    createRecursor () {\n      if (!this.deserializedRecursor) return () => null\n\n      const replay = recursorUtils.replay(this.replayState, () => ({ size: -1, next: this.deserializedRecursor }))\n      this.replayState = replay.state\n      return replay.recursor.next\n    }\n\n    hasSameCtor (expected) {\n      if (this.ctor === expected.ctor) return true\n\n      if (this.functionNameSupportFlags === functionNameSupport.bitFlags) {\n        // The engine used to create the serialization supports the same\n        // function name inference as the current engine. That said, unless\n        // the engine has full support for name inference, it's possible that\n        // names were lost simply due to refactoring. Ctors are not the same\n        // only if the engine has full support, or if ctors were inferred.\n        if (functionNameSupport.hasFullSupport === true || (this.ctor !== null && expected.ctor !== null)) return false\n      } else if (functionNameSupport.isSubsetOf(this.functionNameSupportFlags)) {\n        // The engine used to create the serialization could infer more function\n        // names than the current engine. Assume `expected.ctor` comes from the\n        // current engine and treat the ctors as unequal only if the current\n        // engine could infer a ctor.\n        if (expected.ctor !== null) return false\n      } else {\n        /* istanbul ignore else */\n        if (functionNameSupport.isSupersetOf(this.functionNameSupportFlags)) {\n          // The engine used to create the serialization could infer fewer\n          // function names than the current engine. Treat the ctors as unequal\n          // only if a ctor was in the serialization.\n          if (this.ctor !== null) return false\n        }\n      }\n\n      return true\n    }\n  }\n}\nexports.DeserializedMixin = DeserializedMixin\n"},"hash":"6dfd6161e9197bb44f1b669f79b4364d"}