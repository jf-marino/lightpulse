{"dependencies":[{"name":"function-name-support","loc":{"line":3,"column":36}},{"name":"../constants","loc":{"line":5,"column":26}},{"name":"../getStringTag","loc":{"line":6,"column":29}},{"name":"../isEnumerable","loc":{"line":7,"column":29}},{"name":"../formatUtils","loc":{"line":8,"column":28}},{"name":"../lineBuilder","loc":{"line":9,"column":28}},{"name":"../recursorUtils","loc":{"line":10,"column":30}},{"name":"./object","loc":{"line":11,"column":23}}],"generated":{"js":"'use strict'\n\nconst functionNameSupport = require('function-name-support')\n\nconst constants = require('../constants')\nconst getStringTag = require('../getStringTag')\nconst isEnumerable = require('../isEnumerable')\nconst formatUtils = require('../formatUtils')\nconst lineBuilder = require('../lineBuilder')\nconst NOOP_RECURSOR = require('../recursorUtils').NOOP_RECURSOR\nconst object = require('./object')\n\nconst UNEQUAL = constants.UNEQUAL\nconst SHALLOW_EQUAL = constants.SHALLOW_EQUAL\n\n// Node.js 4 provides Function, more recent versions use GeneratorFunction\nconst generatorsHaveGeneratorTag = getStringTag(function * () {}) === 'GeneratorFunction'\n\nfunction describe (props) {\n  const fn = props.value\n  return new DescribedFunctionValue(Object.assign({\n    nameIsEnumerable: isEnumerable(fn, 'name'),\n    name: typeof fn.name === 'string' ? fn.name : null\n  }, props))\n}\nexports.describe = describe\n\nfunction deserialize (state, recursor) {\n  return new DeserializedFunctionValue(state, recursor)\n}\nexports.deserialize = deserialize\n\nconst tag = Symbol('FunctionValue')\nexports.tag = tag\n\nclass FunctionValue extends object.ObjectValue {\n  constructor (props) {\n    super(props)\n    this.name = props.name\n  }\n\n  formatShallow (theme, indent) {\n    const string = formatUtils.wrap(theme.function.stringTag, this.stringTag) +\n      (this.name ? ' ' + formatUtils.wrap(theme.function.name, this.name) : '') +\n      ' ' + theme.object.openBracket\n\n    return super.formatShallow(theme, indent).customize({\n      finalize (innerLines) {\n        return innerLines.isEmpty\n          ? lineBuilder.single(string + theme.object.closeBracket)\n          : lineBuilder.first(string)\n              .concat(innerLines.withFirstPrefixed(indent.increase()).stripFlags())\n              .append(lineBuilder.last(indent + theme.object.closeBracket))\n      },\n\n      maxDepth () {\n        return lineBuilder.single(string + ' ' + theme.maxDepth + ' ' + theme.object.closeBracket)\n      }\n    })\n  }\n}\nObject.defineProperty(FunctionValue.prototype, 'tag', { value: tag })\n\nclass DescribedFunctionValue extends object.DescribedMixin(FunctionValue) {\n  constructor (props) {\n    super(props)\n    this.nameIsEnumerable = props.nameIsEnumerable\n  }\n\n  compare (expected) {\n    if (this.tag !== expected.tag) return UNEQUAL\n    if (this.name !== expected.name) return UNEQUAL\n    if (this.value && expected.value && this.value !== expected.value) return UNEQUAL\n\n    return super.compare(expected)\n  }\n\n  createPropertyRecursor () {\n    const recursor = super.createPropertyRecursor()\n\n    const skipName = this.nameIsEnumerable\n    if (!skipName) return recursor\n\n    let size = recursor.size\n    if (skipName) {\n      size -= 1\n    }\n\n    if (size === 0) return NOOP_RECURSOR\n\n    const next = () => {\n      const property = recursor.next()\n      if (property) {\n        if (skipName && property.key.value === 'name') {\n          return next()\n        }\n        return property\n      }\n\n      return null\n    }\n\n    return { size, next }\n  }\n\n  serialize () {\n    return [this.name, generatorsHaveGeneratorTag, super.serialize()]\n  }\n}\n\nclass DeserializedFunctionValue extends object.DeserializedMixin(FunctionValue) {\n  constructor (state, recursor) {\n    super(state[2], recursor)\n    this.name = state[0]\n    this.trustStringTag = state[1]\n  }\n\n  compare (expected) {\n    if (this.tag !== expected.tag) return UNEQUAL\n\n    if (this.name !== expected.name) {\n      if (this.functionNameSupportFlags === functionNameSupport.bitFlags) {\n        // The engine used to create the serialization supports the same\n        // function name inference as the current engine. That said, unless\n        // the engine has full support for name inference, it's possible that\n        // names were lost simply due to refactoring. Names are unequal if\n        // the engine has full support, or if names were inferred.\n        if (functionNameSupport.hasFullSupport === true || (this.name !== '' && expected.name !== '')) return UNEQUAL\n      } else if (functionNameSupport.isSubsetOf(this.functionNameSupportFlags)) {\n        // The engine used to create the serialization could infer more function\n        // names than the current engine. Assume `expected.name` comes from the\n        // current engine and treat the names as unequal only if the current\n        // engine could infer a name.\n        if (expected.name !== '') return UNEQUAL\n      } else {\n        /* istanbul ignore else */\n        if (functionNameSupport.isSupersetOf(this.functionNameSupportFlags)) {\n          // The engine used to create the serialization could infer fewer\n          // function names than the current engine. Treat the names as unequal\n          // only if a name was in the serialization.\n          if (this.name !== '') return UNEQUAL\n        }\n      }\n    }\n\n    // Assume `stringTag` is either 'Function' or 'GeneratorFunction', and that\n    // it always equals `ctor`. Since Node.js 4 only provides 'Function', even\n    // for generator functions, only compare `stringTag` if the serialized value\n    // legitimately would have been `Function`, and the expected `stringTag` can\n    // reliably be inferred.\n    if (this.trustStringTag && generatorsHaveGeneratorTag && this.stringTag !== expected.stringTag) return UNEQUAL\n\n    return SHALLOW_EQUAL\n  }\n\n  serialize () {\n    return [this.name, this.trustStringTag, super.serialize()]\n  }\n}\n"},"hash":"1e4423718257b759ceca21c0e3c45e2e"}