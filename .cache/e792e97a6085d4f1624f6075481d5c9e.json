{"dependencies":[{"name":"events","loc":{"line":2,"column":29}},{"name":"fn-name","loc":{"line":3,"column":23}},{"name":"./concurrent","loc":{"line":4,"column":27}},{"name":"./sequence","loc":{"line":5,"column":25}},{"name":"./test","loc":{"line":6,"column":21}}],"generated":{"js":"\"use strict\";const t=require(\"events\"),s=require(\"fn-name\"),e=require(\"./concurrent\"),i=require(\"./sequence\"),a=require(\"./test\");class n extends t{constructor(t){super(),this.bail=t.bail,this.failWithoutAssertions=t.failWithoutAssertions,this.compareTestSnapshot=t.compareTestSnapshot,this.hasExclusive=!1,this.testCount=0,this.tests={concurrent:[],serial:[]},this.hooks={before:[],beforeEach:[],after:[],afterAlways:[],afterEach:[],afterEachAlways:[]},this.pendingTestInstances=new Set,this._emitTestResult=this._emitTestResult.bind(this)}add(t){const e=t.metadata,i=e.type;if(!i)throw new Error(\"Test type must be specified\");if(!t.title&&t.fn&&(t.title=s(t.fn)),\"callee$0$0\"===t.title&&(t.title=null),t.title||(t.title=\"test\"===i?\"[anonymous]\":i),e.always&&\"after\"!==i&&\"afterEach\"!==i)throw new Error('\"always\" can only be used with after and afterEach hooks');if(\"test\"===i)this.testCount++,this.hasExclusive&&!e.exclusive||(e.exclusive&&!this.hasExclusive&&(this.tests.concurrent=[],this.tests.serial=[],this.hasExclusive=!0),e.serial?this.tests.serial.push(t):this.tests.concurrent.push(t));else{if(e.exclusive)throw new Error(`\"only\" cannot be used with a ${i} hook`);this.hooks[i+(e.always?\"Always\":\"\")].push(t)}}_skippedTest(t){return{run:()=>(this._emitTestResult({passed:!0,result:t}),!0)}}_emitTestResult(t){this.pendingTestInstances.delete(t.result),this.emit(\"test\",t)}_buildHooks(t,s,e){return t.map(t=>{const i=this._buildHook(t,s,e);return t.metadata.skipped||t.metadata.todo?this._skippedTest(i):i})}_buildHook(t,s,e){let i=t.title;s&&(i+=` for ${s}`),e||(e=null);const n=new a({contextRef:e,failWithoutAssertions:!1,fn:t.fn,compareTestSnapshot:this.compareTestSnapshot,metadata:t.metadata,onResult:this._emitTestResult,title:i});return this.pendingTestInstances.add(n),n}_buildTest(t,s){return s||(s=null),t=new a({contextRef:s,failWithoutAssertions:this.failWithoutAssertions,fn:t.fn,compareTestSnapshot:this.compareTestSnapshot,metadata:t.metadata,onResult:this._emitTestResult,title:t.title}),this.pendingTestInstances.add(t),t}_buildTestWithHooks(t){if(t.metadata.skipped||t.metadata.todo)return new i([this._skippedTest(this._buildTest(t))],!0);const s={context:{}},e=this._buildHooks(this.hooks.beforeEach,t.title,s),a=this._buildHooks(this.hooks.afterEach,t.title,s);let n=new i([].concat(e,this._buildTest(t,s),a),!0);if(this.hooks.afterEachAlways.length>0){const e=new i(this._buildHooks(this.hooks.afterEachAlways,t.title,s));n=new i([n,e],!1)}return n}_buildTests(t){return t.map(t=>this._buildTestWithHooks(t))}_hasUnskippedTests(){return this.tests.serial.concat(this.tests.concurrent).some(t=>!(t.metadata&&!0===t.metadata.skipped))}build(){const t=new i(this._buildTests(this.tests.serial),this.bail),s=new e(this._buildTests(this.tests.concurrent),this.bail),a=new i([t,s]);let n;if(this._hasUnskippedTests()){const t=new i(this._buildHooks(this.hooks.before)),s=new i(this._buildHooks(this.hooks.after));n=new i([t,a,s],!0)}else n=new i([a],!0);if(this.hooks.afterAlways.length>0){const t=new i(this._buildHooks(this.hooks.afterAlways));n=new i([n,t],!1)}return n}attributeLeakedError(t){for(const s of this.pendingTestInstances)if(s.attributeLeakedError(t))return!0;return!1}}module.exports=n;"},"hash":"c63b7f8b9babd5f79a5981a9ff591426"}