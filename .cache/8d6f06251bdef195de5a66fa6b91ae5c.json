{"dependencies":[{"name":"concordance","loc":{"line":2,"column":28}},{"name":"core-assert","loc":{"line":3,"column":27}},{"name":"observable-to-promise","loc":{"line":4,"column":36}},{"name":"is-observable","loc":{"line":5,"column":29}},{"name":"is-promise","loc":{"line":6,"column":26}},{"name":"./concordance-options","loc":{"line":8,"column":39}},{"name":"./enhance-assert","loc":{"line":9,"column":30}},{"name":"./snapshot-manager","loc":{"line":10,"column":32}}],"generated":{"js":"'use strict';\nconst concordance = require('concordance');\nconst coreAssert = require('core-assert');\nconst observableToPromise = require('observable-to-promise');\nconst isObservable = require('is-observable');\nconst isPromise = require('is-promise');\nconst concordanceOptions = require('./concordance-options').default;\nconst concordanceDiffOptions = require('./concordance-options').diff;\nconst enhanceAssert = require('./enhance-assert');\nconst snapshotManager = require('./snapshot-manager');\n\nfunction formatDescriptorDiff(actualDescriptor, expectedDescriptor, options) {\n\toptions = Object.assign({}, options, concordanceDiffOptions);\n\treturn {\n\t\tlabel: 'Difference:',\n\t\tformatted: concordance.diffDescriptors(actualDescriptor, expectedDescriptor, options)\n\t};\n}\n\nfunction formatDescriptorWithLabel(label, descriptor) {\n\treturn {\n\t\tlabel,\n\t\tformatted: concordance.formatDescriptor(descriptor, concordanceOptions)\n\t};\n}\n\nfunction formatWithLabel(label, value) {\n\treturn formatDescriptorWithLabel(label, concordance.describe(value, concordanceOptions));\n}\n\nclass AssertionError extends Error {\n\tconstructor(opts) {\n\t\tsuper(opts.message || '');\n\t\tthis.name = 'AssertionError';\n\n\t\tthis.assertion = opts.assertion;\n\t\tthis.fixedSource = opts.fixedSource;\n\t\tthis.improperUsage = opts.improperUsage || false;\n\t\tthis.operator = opts.operator;\n\t\tthis.values = opts.values || [];\n\n\t\t// Raw expected and actual objects are stored for custom reporters\n\t\t// (such as wallaby.js), that manage worker processes directly and\n\t\t// use the values for custom diff views\n\t\tthis.raw = opts.raw;\n\n\t\t// Reserved for power-assert statements\n\t\tthis.statements = [];\n\n\t\tif (opts.stack) {\n\t\t\tthis.stack = opts.stack;\n\t\t}\n\t}\n}\nexports.AssertionError = AssertionError;\n\nfunction getStack() {\n\tconst obj = {};\n\tError.captureStackTrace(obj, getStack);\n\treturn obj.stack;\n}\n\nfunction wrapAssertions(callbacks) {\n\tconst pass = callbacks.pass;\n\tconst pending = callbacks.pending;\n\tconst fail = callbacks.fail;\n\tconst log = callbacks.log;\n\n\tconst noop = () => {};\n\tconst makeRethrow = reason => () => {\n\t\tthrow reason;\n\t};\n\n\tconst assertions = {\n\t\tpass() {\n\t\t\tpass(this);\n\t\t},\n\n\t\tfail(message) {\n\t\t\tfail(this, new AssertionError({\n\t\t\t\tassertion: 'fail',\n\t\t\t\tmessage: message || 'Test failed via `t.fail()`'\n\t\t\t}));\n\t\t},\n\n\t\tis(actual, expected, message) {\n\t\t\tif (Object.is(actual, expected)) {\n\t\t\t\tpass(this);\n\t\t\t} else {\n\t\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tconst expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);\n\n\t\t\t\tif (result.pass) {\n\t\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\t\tassertion: 'is',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\t\tvalues: [formatDescriptorWithLabel('Values are deeply equal to each other, but they are not the same:', actualDescriptor)]\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\t\tassertion: 'is',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\t\tvalues: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tnot(actual, expected, message) {\n\t\t\tif (Object.is(actual, expected)) {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'not',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatWithLabel('Value is the same as:', actual)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass(this);\n\t\t\t}\n\t\t},\n\n\t\tlog(text) {\n\t\t\tlog(this, text);\n\t\t},\n\n\t\tdeepEqual(actual, expected, message) {\n\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\tif (result.pass) {\n\t\t\t\tpass(this);\n\t\t\t} else {\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tconst expectedDescriptor = result.expected || concordance.describe(expected, concordanceOptions);\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'deepEqual',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatDescriptorDiff(actualDescriptor, expectedDescriptor)]\n\t\t\t\t}));\n\t\t\t}\n\t\t},\n\n\t\tnotDeepEqual(actual, expected, message) {\n\t\t\tconst result = concordance.compare(actual, expected, concordanceOptions);\n\t\t\tif (result.pass) {\n\t\t\t\tconst actualDescriptor = result.actual || concordance.describe(actual, concordanceOptions);\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'notDeepEqual',\n\t\t\t\t\tmessage,\n\t\t\t\t\traw: {actual, expected},\n\t\t\t\t\tvalues: [formatDescriptorWithLabel('Value is deeply equal:', actualDescriptor)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass(this);\n\t\t\t}\n\t\t},\n\n\t\tthrows(fn, err, message) {\n\t\t\tlet promise;\n\t\t\tif (isPromise(fn)) {\n\t\t\t\tpromise = fn;\n\t\t\t} else if (isObservable(fn)) {\n\t\t\t\tpromise = observableToPromise(fn);\n\t\t\t} else if (typeof fn !== 'function') {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.throws()` must be called with a function, Promise, or Observable',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', fn)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet coreAssertThrowsErrorArg;\n\t\t\tif (typeof err === 'string') {\n\t\t\t\tconst expectedMessage = err;\n\t\t\t\tcoreAssertThrowsErrorArg = error => error.message === expectedMessage;\n\t\t\t} else {\n\t\t\t\t// Assume it's a constructor function or regular expression\n\t\t\t\tcoreAssertThrowsErrorArg = err;\n\t\t\t}\n\n\t\t\tconst test = (fn, stack) => {\n\t\t\t\tlet actual;\n\t\t\t\tlet threw = false;\n\t\t\t\ttry {\n\t\t\t\t\tcoreAssert.throws(() => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tfn();\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tactual = err;\n\t\t\t\t\t\t\tthrew = true;\n\t\t\t\t\t\t\tthrow err;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, coreAssertThrowsErrorArg);\n\t\t\t\t\treturn actual;\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tstack,\n\t\t\t\t\t\tvalues: threw ?\n\t\t\t\t\t\t\t[formatWithLabel('Threw unexpected exception:', actual)] :\n\t\t\t\t\t\t\tnull\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (promise) {\n\t\t\t\t// Record stack before it gets lost in the promise chain.\n\t\t\t\tconst stack = getStack();\n\t\t\t\tconst intermediate = promise.then(value => {\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'throws',\n\t\t\t\t\t\tmessage: 'Expected promise to be rejected, but it was resolved instead',\n\t\t\t\t\t\tvalues: [formatWithLabel('Resolved with:', value)]\n\t\t\t\t\t});\n\t\t\t\t}, reason => test(makeRethrow(reason), stack));\n\n\t\t\t\tpending(this, intermediate);\n\t\t\t\t// Don't reject the returned promise, even if the assertion fails.\n\t\t\t\treturn intermediate.catch(noop);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst retval = test(fn);\n\t\t\t\tpass(this);\n\t\t\t\treturn retval;\n\t\t\t} catch (err) {\n\t\t\t\tfail(this, err);\n\t\t\t}\n\t\t},\n\n\t\tnotThrows(fn, message) {\n\t\t\tlet promise;\n\t\t\tif (isPromise(fn)) {\n\t\t\t\tpromise = fn;\n\t\t\t} else if (isObservable(fn)) {\n\t\t\t\tpromise = observableToPromise(fn);\n\t\t\t} else if (typeof fn !== 'function') {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'notThrows',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notThrows()` must be called with a function, Promise, or Observable',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', fn)]\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst test = (fn, stack) => {\n\t\t\t\ttry {\n\t\t\t\t\tcoreAssert.doesNotThrow(fn);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tthrow new AssertionError({\n\t\t\t\t\t\tassertion: 'notThrows',\n\t\t\t\t\t\tmessage,\n\t\t\t\t\t\tstack,\n\t\t\t\t\t\tvalues: [formatWithLabel('Threw:', err.actual)]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (promise) {\n\t\t\t\t// Record stack before it gets lost in the promise chain.\n\t\t\t\tconst stack = getStack();\n\t\t\t\tconst intermediate = promise.then(noop, reason => test(makeRethrow(reason), stack));\n\t\t\t\tpending(this, intermediate);\n\t\t\t\t// Don't reject the returned promise, even if the assertion fails.\n\t\t\t\treturn intermediate.catch(noop);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\ttest(fn);\n\t\t\t\tpass(this);\n\t\t\t} catch (err) {\n\t\t\t\tfail(this, err);\n\t\t\t}\n\t\t},\n\n\t\tifError(actual, message) {\n\t\t\tif (actual) {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'ifError',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Error:', actual)]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tpass(this);\n\t\t\t}\n\t\t},\n\n\t\tsnapshot(expected, optionsOrMessage, message) {\n\t\t\tconst options = {};\n\t\t\tif (typeof optionsOrMessage === 'string') {\n\t\t\t\tmessage = optionsOrMessage;\n\t\t\t} else if (optionsOrMessage) {\n\t\t\t\toptions.id = optionsOrMessage.id;\n\t\t\t}\n\t\t\toptions.expected = expected;\n\t\t\toptions.message = message;\n\n\t\t\tlet result;\n\t\t\ttry {\n\t\t\t\tresult = this._test.compareWithSnapshot(options);\n\t\t\t} catch (err) {\n\t\t\t\tif (!(err instanceof snapshotManager.SnapshotError)) {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\n\t\t\t\tconst improperUsage = {name: err.name, snapPath: err.snapPath};\n\t\t\t\tif (err instanceof snapshotManager.VersionMismatchError) {\n\t\t\t\t\timproperUsage.snapVersion = err.snapVersion;\n\t\t\t\t\timproperUsage.expectedVersion = err.expectedVersion;\n\t\t\t\t}\n\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'Could not compare snapshot',\n\t\t\t\t\timproperUsage\n\t\t\t\t}));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (result.pass) {\n\t\t\t\tpass(this);\n\t\t\t} else if (result.actual) {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'Did not match snapshot',\n\t\t\t\t\tvalues: [formatDescriptorDiff(result.actual, result.expected, {invert: true})]\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tfail(this, new AssertionError({\n\t\t\t\t\tassertion: 'snapshot',\n\t\t\t\t\tmessage: message || 'No snapshot available, run with --update-snapshots'\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t};\n\n\tconst enhancedAssertions = enhanceAssert(pass, fail, {\n\t\ttruthy(actual, message) {\n\t\t\tif (!actual) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'truthy',\n\t\t\t\t\tmessage,\n\t\t\t\t\toperator: '!!',\n\t\t\t\t\tvalues: [formatWithLabel('Value is not truthy:', actual)]\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tfalsy(actual, message) {\n\t\t\tif (actual) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'falsy',\n\t\t\t\t\tmessage,\n\t\t\t\t\toperator: '!',\n\t\t\t\t\tvalues: [formatWithLabel('Value is not falsy:', actual)]\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\ttrue(actual, message) {\n\t\t\tif (actual !== true) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'true',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Value is not `true`:', actual)]\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tfalse(actual, message) {\n\t\t\tif (actual !== false) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'false',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [formatWithLabel('Value is not `false`:', actual)]\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tregex(string, regex, message) {\n\t\t\tif (typeof string !== 'string') {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.regex()` must be called with a string',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', string)]\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!(regex instanceof RegExp)) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.regex()` must be called with a regular expression',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', regex)]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (!regex.test(string)) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'regex',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [\n\t\t\t\t\t\tformatWithLabel('Value must match expression:', string),\n\t\t\t\t\t\tformatWithLabel('Regular expression:', regex)\n\t\t\t\t\t]\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\tnotRegex(string, regex, message) {\n\t\t\tif (typeof string !== 'string') {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notRegex()` must be called with a string',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', string)]\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!(regex instanceof RegExp)) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\timproperUsage: true,\n\t\t\t\t\tmessage: '`t.notRegex()` must be called with a regular expression',\n\t\t\t\t\tvalues: [formatWithLabel('Called with:', regex)]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (regex.test(string)) {\n\t\t\t\tthrow new AssertionError({\n\t\t\t\t\tassertion: 'notRegex',\n\t\t\t\t\tmessage,\n\t\t\t\t\tvalues: [\n\t\t\t\t\t\tformatWithLabel('Value must not match expression:', string),\n\t\t\t\t\t\tformatWithLabel('Regular expression:', regex)\n\t\t\t\t\t]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Object.assign(assertions, enhancedAssertions);\n}\nexports.wrapAssertions = wrapAssertions;\n"},"hash":"f099c0fd098aba45eef1c2a67e5ea55f"}