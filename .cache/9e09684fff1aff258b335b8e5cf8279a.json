{"dependencies":[{"name":"vm","loc":{"line":3,"column":19}}],"generated":{"js":"'use strict'\n\nconst vm = require('vm')\n\nconst context = vm.createContext()\nfunction test (code) {\n  try {\n    return vm.runInContext(`(function () {\n      'use strict'\n      ${code}\n    })()`, context) === true\n  } catch (err) {\n    return false\n  }\n}\n\nconst support = {}\n\n// Tests from <https://github.com/kangax/compat-table/blob/c0a3b882b27e4e9f4ef449a1c985ee7857326b94/data-es6.js#L12733:L13115>.\nsupport.functionStatements = test(`\n  function foo(){};\n  return foo.name === 'foo' &&\n    (function(){}).name === '';\n`)\n\nsupport.functionExpressions = test(`\n  return (function foo(){}).name === 'foo' &&\n    (function(){}).name === '';\n`)\n\nsupport.newFunction = test(`\n  return (new Function).name === \"anonymous\";\n`)\n\nsupport.boundFunctions = test(`\n  function foo() {};\n  return foo.bind({}).name === \"bound foo\" &&\n    (function(){}).bind({}).name === \"bound \";\n`)\n\nsupport.functionVariables = test(`\n  var foo = function() {};\n  var bar = function baz() {};\n  return foo.name === \"foo\" && bar.name === \"baz\";\n`)\n\nsupport.functionObjectMethods = test(`\n  var o = { foo: function(){}, bar: function baz(){}};\n  o.qux = function(){};\n  return o.foo.name === \"foo\" &&\n         o.bar.name === \"baz\" &&\n         o.qux.name === \"\";\n`)\n\nsupport.accessorProperties = test(`\n  var o = { get foo(){}, set foo(x){} };\n  var descriptor = Object.getOwnPropertyDescriptor(o, \"foo\");\n  return descriptor.get.name === \"get foo\" &&\n         descriptor.set.name === \"set foo\";\n`)\n\nsupport.shorthandMethods = test(`\n  var o = { foo(){} };\n  return o.foo.name === \"foo\"\n`)\n\nsupport.symbolKeyedMethods = test(`\n  var sym1 = Symbol(\"foo\");\n  var sym2 = Symbol();\n  var o = {\n    [sym1]: function(){},\n    [sym2]: function(){}\n  };\n\n  return o[sym1].name === \"[foo]\" &&\n         o[sym2].name === \"\";\n`)\n\nsupport.classStatements = test(`\n  class foo {};\n  class bar { static name() {} };\n  return foo.name === \"foo\" &&\n    typeof bar.name === \"function\";\n`)\n\nsupport.classExpressions = test(`\n  return class foo {}.name === \"foo\" &&\n    typeof class bar { static name() {} }.name === \"function\";\n`)\n\nsupport.classVariables = test(`\n  var foo = class {};\n  var bar = class baz {};\n  var qux = class { static name() {} };\n  return foo.name === \"foo\" &&\n         bar.name === \"baz\" &&\n         typeof qux.name === \"function\";\n`)\n\nsupport.classObjectMethods = test(`\n  var o = { foo: class {}, bar: class baz {}};\n  o.qux = class {};\n  return o.foo.name === \"foo\" &&\n         o.bar.name === \"baz\" &&\n         o.qux.name === \"\";\n`)\n\nsupport.classPrototypeMethods = test(`\n  class C { foo(){} };\n  return (new C).foo.name === \"foo\";\n`)\n\nsupport.classStaticMethods = test(`\n  class C { static foo(){} };\n  return C.foo.name === \"foo\";\n`)\n\nexports.support = Object.freeze(support)\n\nconst hasFullSupport =\n  support.functionStatements &&\n  support.functionExpressions &&\n  support.newFunction &&\n  support.boundFunctions &&\n  support.functionVariables &&\n  support.functionObjectMethods &&\n  support.accessorProperties &&\n  support.shorthandMethods &&\n  support.symbolKeyedMethods &&\n  support.classStatements &&\n  support.classExpressions &&\n  support.classVariables &&\n  support.classObjectMethods &&\n  support.classPrototypeMethods &&\n  support.classStaticMethods\nexports.hasFullSupport = hasFullSupport\n\nconst bitFlags = [\n  'functionStatements',\n  'functionExpressions',\n  'newFunction',\n  'boundFunctions',\n  'functionVariables',\n  'functionObjectMethods',\n  'accessorProperties',\n  'shorthandMethods',\n  'symbolKeyedMethods',\n  'classStatements',\n  'classExpressions',\n  'classVariables',\n  'classObjectMethods',\n  'classPrototypeMethods',\n  'classStaticMethods'\n  // Add new flags at the end. Reordering flags is a breaking change.\n].reduce((acc, key, index) => {\n  return support[key] === true\n    ? acc + (1 << index)\n    : acc\n}, 0b0)\nexports.bitFlags = bitFlags\n\nexports.isSubsetOf = otherFlags => (bitFlags & otherFlags) === bitFlags\nexports.isSupersetOf = otherFlags => (bitFlags & otherFlags) === otherFlags\n"},"hash":"a06158b80ae5722579b8379e9f05afd6"}